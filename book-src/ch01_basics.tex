% - * - coding: utf-8 - * -
\ chapter {Basics of Interpretation} \ label {chapter: basics}

\ initial {0.75ex} {0.0ex} {In} { \ kern 1ex this chapter} describes a basic interpreter, ideas
which is a red thread through most of this book. He deliberately
made simple and closer to ~ Scheme than to Lisp; this will allow us
in the following, describe Lisp in terms of Scheme. We will touch on the following topics in this
introductory chapter: the essence of interpretation; known pair of functions \ ic {eval} and
\ ic {apply}; expected properties of environments and functions. In short, we will begin
consider here what we will study in more detail in the following chapters, hoping,
that you will not be frightened away by the abyss of ignorance on both sides of the bridge that we will go.

\ bigskip

The interpreter and its variants will be written on Scheme without using
which "~ or significant features of this dialect.

\ begingroup
\ ForLayout {display} { \ setlength { \ emergencystretch } {3em}}
In books about Lisp, they rarely give up the narcissistic temptation to describe
Lisp with the help of Lisp. The beginning of the tradition was laid by the first
\ LISP ~ 1.5 \ cite {mae + 62}, and subsequently this approach has spread widely.
Here are just a few of the existing examples: \ cite {rib69}, \ cite {gre77},
\ cite {que82}, \ cite {cay83}, \ cite {cha80}, \ cite {sj93}, \ cite {rey72},
\ cite {gor75}, \ cite {ss75}, \ cite {all78}, \ cite {mcc78b}, \ cite {lak80},
\ cite {hen80}, \ cite {bm82}, \ cite {cli84}, \ cite {fw84}, \ cite {drs84},
\ cite {as85}, \ cite {r3r86}, \ cite {mas86}, \ cite {dyb87}, \ cite {wh89},
\ cite {kes88}, \ cite {lf88}, \ cite {dil88}, \ cite {kam90}. \ par \ endgroup

These interpreters vary quite widely, both with the languages ​​they implement
and use for implementation, and, more importantly, the goals they
pursue. For example, the interpreter from ~ \ cite {lak80} shows how objects
and the concept of computer graphics is naturally implemented in Lisp;
and ~ the interpreter, described in ~ \ cite {bm82}, was created for an explicit complexity measurement
interpreted programs.

\ indexR {implementation language}
\ indexR {language! realizable}
The language that \ emph {used} for implementation also plays a significant role. If in ~ it
there is an assignment and access to ~ memory ( \ ic {set-car!} and \ ic {set-cdr!}), this gives
b \ ' {o} greater freedom and makes the source code of the interpreter more compact. we
we get the opportunity to describe the language in terms that are close to machine
instructions. And, ~ like with machine instructions, despite the fact that such
description can be difficult to compose, no ~ there is no doubt that ~ that
exactly what each particular line does. Even if such a description takes
more space than a high-level one, it gives a more accurate understanding of the meaning
occurring at the interpretation "--- for us it is important ~ it.

\ begin {figure} \ centering
\ input {figures / fig1.1}
\ caption {Difficulty levels.} \ label {basics / fig: richness-plot}
\ end {figure}

The figure ~ \ ref {basics / fig: richness-plot} shows a comparison of the difficulty levels
defining (on the ~ axis ~ $ x $ ) and determined (on the ~ axis ~ $ y $ ) languages ​​for some of
interpreters. Here the development of our knowledge with time is clearly visible: all
more complex problems are solved with the use of increasingly limited
opportunities. This book corresponds to a vector that begins using
high-level Lisp to implement Scheme, and ends with the implementation
High-level Lisp with ~ using only $ \ lambda $ "= calculus.


\ section {Calculations} \ label {basics / sect: evaluation}

\ indexC {eval}
\ indexR {calculator}
The most important part of the Lisp interpreter is in one function, around which
everything revolves. This function, called \ ic {eval}, takes input
program, and at the output gives the result of its execution. Explicit presence of the performer
code is by no means accidental, but, conversely, is characteristic and deliberate
implemented line of Lisp.

\ indexR {language! universal}
\ indexR {universal language}
\ indexR {Turing machine} \ indexR {Turing, machine}
A programming language is called \ term {universal}, if it is not ~ inferior
in the expressive possibilities of the Turing machine. Since the Turing machine is quite
primitive, it is not difficult to develop a language that would satisfy this condition;
Indeed, it would be more difficult to come up with a language that would be useful, but with
This would not be complete in Turing.

\ indexR {Thesis of Church} \ indexR {Church, thesis}
In accordance with Church's thesis, any computable function can be written in
any turing-complete language. The Lisp interpreter can be represented as such
a function that accepts programs and returns the results of their execution. So
that if such a function exists at all, it can be written on any
tyuring-complete language. Therefore, the Lisp function \ ic {eval} can
to write down in particular on that same Lisp. There is no contradiction in this,
exactly so, for example, you can implement Fortran on Fortran.

But ~ what makes Lisp unique (and ~ justifies the explicit description of \ ic {eval}), so this
small size of interpreter code: usually from ~ one to ~ twenty pages
depending on the detail. \ footnote * {The interpreter described in this chapter,
it takes about 150 ~ lines.} This is the result of the desire to make the language consistent,
with a minimum number of exceptions to the rules, and, most importantly, with a ~ simple,
but expressive syntax.

\ indexCS {eval} {properties}
The very existence of \ ic {eval}, as well as the possibility of its description in Lisp
have several interesting consequences.
\ begin {itemize}
  \ item You can learn Lisp or by reading the manual (which describes
        all available functions), or by studying the actual function ~ \ ic {eval}.
        The second approach is complicated by the fact that we must already know Lisp in order to
        understand the description of \ ic {eval}; But in fact Lisp's knowledge of the idea must be
        \ emph {consequence} of studying \ ic {eval}, rather than \ emph {premise} for
        him. In fact, it is enough to know only that part of Lisp that
        is used to describe \ ic {eval}. In addition, the language defined
        one \ ic {eval}, not ~ is the whole Lisp: it is only the essence of the language,
        In it only special forms and a few primitive
        functions.

        All the same, in ~ the opportunity to learn the language by two different, but all the same
        bound ways is undoubted plus Lisp.

  \ item The fact that \ ic {eval} is written in Lisp, means also that
        The development environment is an integral part of the language and does not require
        significant overhead costs. The development environment is understood as
        such things as a debugger, a tracer, or the ability to reverse
        course \ cite {lie87}. In practice, the implementation of such tools "---
        this is just a refinement of \ ic {eval}, for example, that it would output
        messages when calling functions, pauses the calculations
        in ~ interesting places and ~ so ~ next.

        For a long time, the development environment with such capabilities was unique
        for Lisp. But even today, the fact that \ ic {eval} can be described on the very
        Lisp, makes it easy to experiment with new options
        implementation of calculations or debugging.

  \ item Finally, \ ic {eval} itself is capable of being an instrument
        programming. It is quite a controversial tool, because
        the use of \ ic {eval} requires the presence of an integer
        interpreter or compiler during the code execution time; but also
        A more serious problem is the impossibility of using
        case of some optimizations. In other words, the use of
        \ ic {eval} has its own price. In some cases, its use
        is completely justified, for example, when Lisp is used to describe
        and the implementation of metalanguages.

        In addition to the tangible cost of use, the semantics \ ic {eval} are often
        is ambiguous. That's why she did not enter ~ the standard before
        revision \ RnRS ~ \ cite {cr91b, kcr98}. \ seePage [chapter: reflection]
\ end {itemize}


\ section {Base calculator} \ label {basics / sect: basic-evaluator}

\ indexR {variables! free} \ indexR {variables}
\ indexR {free variables}
\ indexR {binding forms} \ indexR {form! binding}
\ indexR {environment}
\ indexC {evaluate}
We will distinguish between \ term {free} and \ term {related variables} in the program .
The variable is free, if there is not a single binding form (like \ ic {let} or
\ ic {lambda}) does not bind it to any value. In the opposite case, it
called bound. Accordingly, free variables can be any
meaning, and one can not definitely say which one, without going beyond
function. A data structure that associates variables with their values,
is called \ term {environment}. Thus, the function \ ic {evaluate} \ footnote {How
you know, the "native" function-calculator Scheme is called \ ic {eval}. To their
not to be confused, our function will be called \ ic {evaluate}. For the same reasons, the local
the analog of \ ic {apply} will be called \ ic {invoke}. Less overlapping names "---
less problems.} has two arguments: the program and the environment in which it is
must be executed:

\ begin {code: lisp}
(define (evaluate exp env) ...)
\ end {code: lisp}


\ section {Calculating atoms} \ label {basics / sect: evaluating-atoms}

One of the key features of Lisp is that programs are written
the same constructions as the rest of the data. But since any record
implies certain conventions, let's talk about such conventions for recording
programs. Main conventions: variables are written with symbols (their own
names), and function calls "--- lists where the first element" is the called
function, and the rest "--- its arguments.

\ indexR {atom}
Like any other compiler, \ ic {evaluate} starts its work
with a ~ parsing of the expression passed to it to find out what exactly
it means. In this sense, the title of the section is not quite right: we
consider not literally the calculation of atoms, but the interpretation of programs,
consisting of atoms. Now it is important to distinguish the program from its presentation
(letter from the sheet of paper on which it is written). The function ~ \ ic {evaluate}
works with a ~ representation of programs, on it she learns the instructions prescribed by the program
action and performs ~ them.

% \ ForLayout {display}
\ begin {minipage} { \ textwidth - \ parindent }
\ indexC {atom "?}
\ begin {code: lisp}
(define (evaluate exp env)
  (if (atom? exp); \ ic {(atom? exp)} { \ equals } \ ic {(not (pair? exp))}
      ...
      (case (car exp)
        ...
        (else ...))))
\ end {code: lisp}
\ end {minipage}

If the expression is not a ~ list, then it is most likely a character, or a number, or
some line. If it's all the same symbol, then it represents
\ term {variable}, and its value is stored in the environment:

\ begin {code: lisp}
(define (evaluate exp env)
  (if (atom? exp)
      (if (symbol? exp) (lookup exp env) exp)
      (case (car exp)
        ...
        (else ...))))
\ end {code: lisp}

The function ~ \ ic {lookup} (which is considered in more detail on
page ~ \ pageref {basics / sect: repr-the-env}) knows how to find the value
variable in the environment. Here is its prototype:

\ indexC {lookup}
\ begin {code: lisp}
(lookup | \ ii {variable} | | \ ii {environment} |) | \ is | | | \ ii {value} |
\ end {code: lisp}

\ indexR {variables, connection with ~ symbols}
\ indexR {characters! link to ~ variables}
As you can see, an implicit conversion of a symbol to a variable takes place here. If
be more meticulous, then instead of \ ic {(lookup exp env)} we need to write that "~
like:

\ begin {code: lisp}
... (lookup (symbol-> variable exp) env) ...
\ end {code: lisp}

\ indexR {casting}
\ indexR {second-class objects}
In this case, we explicitly say that the symbol ~ \ ic {exp}, whose value is the name
variable must be turned into a ~ variable. It also emphasizes the fact that,
that the function \ ic {symbol-> variable} \ footnote {Personally, I do not like to call functions
type conversions \ ic { \ ii {x} "~> \ ii {y}}, because it's more difficult to understand chains
transformations. The notation \ ic {( \ ii {y} "~> \ ii {z} ( \ ii {x}" ~> \ ii {y} ...))} is not so
is obvious, like \ ic {( \ ii {z} <"~ \ ii {y} ( \ ii {y} <" ~ \ ii {x} ...))}. Although, with a different
hand, a single entry \ ic { \ ii {z} <"~ \ ii {y}} is not as easy to read as
\ ic { \ ii {y} "~> \ ii {z}} You have to choose.} does not translate \ ic {exp} itself
in itself; it turns the syntactic entity (symbol) into a ~ semantic
(variable). In fact, the variables "are only imaginary objects,
which the language and the programmer gave what "~ that names, and which for the sake of convenience
are used in the form of names. The method of representing names is also chosen for reasons
convenience, since Lisp has a basic type of characters. In this case
\ ic {symbol-> variable} does nothing, although it could actually be applied
some other form of writing a variable name, for example: a string consisting of
from the dollar sign and the variable name; in this case, of course, the same,
\ ic {symbol-> variable} will be more complicated.

If the variables were really only imaginary, then \ ic {lookup}
I would not know how to handle my first argument, since it expects something
<< material >>. So we need to convert the variable to its program
representation, some unique key, by which \ ic {lookup} can
find the variable in the environment. So it was even more accurate to write down:

\ ForLayout {display} { \ begingroup
\ lstset {aboveskip = \ smallskipamount , belowskip = \ smallskipamount }}

\ begin {code: lisp}
... (lookup (variable-> key (symbol-> variable exp)) env) ...
\ end {code: lisp}

\ ForLayout {display} { \ endgroup }

However, congenital laziness laziness insists on the use of symbols for
keys. So \ ic {variable "~> key}" is just the inverse function
to ~ \ ic {symbol \ discretionary {->} {} {->} variable}, and their consistent application
does not change ~ \ ic {exp} in any way.

\ indexR {autocycling} \ indexR {autocytotyping mechanism}
If the expression is atomic (then ~ is not ~ a list) and not ~ is a symbol,
then it is tempting to consider it a representation of some constant
with an appropriate value. This behavior is called a mechanism
\ term {autocasting}. An auto-cited object does not require explicit citation and
has an eigenvalue. For examples, you can refer to ~ \ cite {cha96}.

But is this behavior correct? First, not ~ always atomic
objects designate themselves. For example, the line \ ic {"a? B: c"} could mean
call the compiler ~ C, then call the resulting program and substitute
the value returned to it instead of this line.

With other objects (like functions) it is not at all clear how their
\ emph {compute}. For example, it is clear that the value of the variable \ ic {car} is
function that returns the left element of the pair, but what is the value of the
functions \ ii {car}? Most often, attempts to calculate the value of a function are considered
erroneous.

\ indexC {()} \ indexR {empty list, \ protect \ ic {()}}
Another example of a problem value "is an empty list ~ \ ic {()}. Judging by the fact that
this is a list, it must mean a function call. But only in ~ it is not
neither arguments, nor the function itself. Such a record in ~ Scheme is forbidden and is
syntax error.

Therefore, it is necessary to carefully analyze the program and autocat
only those data for which it is clearly worth doing, for example: numbers, lines
and ~ signs. \ seePage [basics / evaluating-forms / ssect: quoting] So we write down
following:

\ ForLayout {display} { \ begingroup
\ lstset {aboveskip = \ smallskipamount , belowskip = \ smallskipamount }}

\ begin {code: lisp}
(define (evaluate exp env)
  (if (atom? exp)
      (cond ((symbol? exp) (lookup exp env))
            ((or (number? exp) (string? exp) (char? exp)
                 (boolean? exp) (vector? exp))
             exp)
            (else (wrong "Can not evaluate" exp)))
      ...))
\ end {code: lisp}

\ ForLayout {display} { \ endgroup }

\ indexR {errors! processing options}
\ indexC {wrong}
\ phantomlabel {basic / atoms / para: the-first-error}
In this fragment of code, the first case is seen when errors can occur.
Most of the LISP systems have their own processing mechanisms
Exceptional situations that are not easy to make bearable. In case of error
we call \ ic {wrong} \ footnote {Notice, not the ~ << function \ ic {wrong} >>. Variants of its
implementations are discussed in more detail in the ~ \ ref {compilation / sect: exception} section .}
and pass it to the first argument string. In the ~ line there is a text description
errors, and the following arguments carry additional information about the fact that
caused a problem. Systems with a rudimentary error handling mechanism usually
in the case of problems, they give out some "~ incomprehensible inscriptions like \ ic {" Bus error: core
dumped "} and die. Others stop current calculations and return
to the ~ dialog mode. A ~ third can be associated with a ~ calculated expression
A special exception handler that will intercept the abandoned object,
describing the error, and will already decide on it what to do next.
\ seePage [compilation / sect: exception] In some cases, even implemented
a semblance of an expert system that analyzes the error that caused its code and
gives the user options for correcting it. In general, it is difficult to say unequivocally,
what to do in case of error.


\ section {Compute forms} \ label {basics / sect: evaluating-forms}

\ indexR {special forms}
\ indexR {form! special}
\ indexR {Lisp! Special Forms}
Each language has a number of "untouchable" syntactic
constructions: they can not be adequately redefined and generally should not be touched.
In Lisp, such constructions are called \ term {special forms}. They
are represented by lists where the first element "is a certain symbol,
belonging to the set of \ term {special operators} (or syntactic
keywords, as they are called in ~ Scheme).

\ indexR {functions! primitives}
\ indexR {primitives}
\ indexR {Lisp dialects}
The specific Lisp dialect is characterized by a set of special forms and a library
primitive functions (these functions can not be defined in the dialect itself, since
they are closely related to the implementation; for example, for Scheme this is ~ \ ic {call / cc}).

In some sense, Lisp is only an applied $ \ lambda $ "= calculus
together with an expanding set of special forms. Specificity of each specific
the Lisp dialect lies only in this set. The ~ Scheme uses a minimum
a set of special operators ( \ ic {quote}, \ ic {if}, \ ic {set!} and ~ \ ic {lambda}),
whereas { \ CommonLisp } (CLtL2 ~ \ cite {ste90}) defines more than thirty, describing
thus, cases where a highly efficient machine can be generated
code.

Since special forms are written literally, their parsing
simple, one \ ic {case} expression suffices: you just have to look at the first element
list. If the form does not begin with a special operator, it means
application function. At the moment, we confine ourselves to a small subset
special forms: \ ic {quote}, \ ic {if}, \ ic {begin}, \ ic {set!} and \ ic {lambda}.
(In the following chapters we introduce other, more specialized forms.)

\ ForLayout {display} { \ begingroup
\ lstset {aboveskip = \ smallskipamount , belowskip = \ smallskipamount }}

\ indexC {evaluate}
\ begin {code: lisp}
(define (evaluate e env)
  (if (atom? e)
      (cond ((symbol? e) (lookup e env))
            ((or (number? e) (string? e) (char? e)
                 (boolean? e) (vector? e)) e)
            (else (wrong "Can not evaluate"))))
      (case (car e)
        ((quote) (cadr e))
        ((if) (if (evaluate (cadr e) env)
                      (evaluate (caddr e) env)
                      (evaluate (cadddr e) env)))
        ((begin) (eprogn (cdr e) env))
        ((set!) (update! (cadr e) env (evaluate (caddr e) env)))
        ((lambda) (make-function (cadr e) (cddr e) env))
        (else (invoke (evaluate (car e) env)
                          (evlis (cdr e) env))))))
\ end {code: lisp}

\ ForLayout {display} { \ endgroup }

\ indexR {syntax! if @ \ protect \ ic {if}}
To simplify the definition, the parsing is left minimal: we
do not ~ check if the quotes are written correctly, is it really \ ic {if} passed
three arguments \ footnote { \ ic {if} does not necessarily take a condition and exactly two
alternatives. For example, in ~ Scheme and { \ CommonLisp } \ ic {if} can take both
two, and three arguments; \ ic {if} to ~ { \ EuLisp } and { \ ISLisp } only
ternary; { \ LeLisp } in case the condition is false, calculates the remainder
form ~ \ ic {if}, wrapping it in ~ \ ic {begin}.} and ~ so ~ next. We consider it a priori
interpreted programs are syntactically correct.


\ subsection {Citation} \ label {basics / evaluating-forms / ssect: quoting}

\ indexC {quote}
\ indexE {M-Expressions} \ indexE {S-Expressions}
\ indexR {programs! as data} \ indexR {values! as programs}
\ indexR {quotes}
The special form \ ic {quote} allows you to write down a value that, without
citation would be confused with some kind of expression. Such a mechanism is necessary,
if the programs are also a data type in ~ the language "--- it is necessary ~ the same as" ~ then
differentiate where the program is written, and where the data is. If a different
syntax, then this problem would not have arisen. For example, initially in Lisp
planned M "= expressions \ cite {mcc60} for writing actions on the data, and themselves
The data should have been written with S "= expressions." This would solve the problem
division of the code and data, but it would have made it impossible to make any macros "---
A very useful thing to extend the syntax. As it were, M "= expressions
for a long time ~ did not live \ cite {mcc78a}, programs and data began to be recorded
exclusively S "= expressions. Therefore in Lisp there is a special form \ ic {quote},
which serves to separate the code and data.

The essence of quoting is to return the expression following the keyword,
<< as-is >>, without its calculation. This is clearly visible in the following code snippet:

\ begin {code: lisp}
... (case (car e)
      ((quote) (cadr e)) ...) ...
\ end {code: lisp}

\ indexR {quotes! explicit and implicit}
Also interesting is the question: is there a difference between explicit and implicit quoting,
for example, between \ ic {33} and \ ic {'33}, or between \ footnote {Recall: in ~ Scheme
the entry \ ic { \ # (...)} stands for the quoted vector.} \ ic { \ # (fa do sol)} and
\ ic {' \ # (fa do sol)}? If the first comparison occurs between direct
values, and like everything would be obvious, in the second case they compare
compound objects (although for Lisp they are formally atoms). It's easy
come up with several possible interpretations of this expression. Citation
returns an argument as a value, but the entry \ ic { \ # (fa do sol)} could ~ be
return each time a new vector of three characters. In other words, \ ic { \ # (fa
do sol)} could simply be a shortened expression for the expression \ ic {(vector 'fa' do
'sol)}, which, of course, will mean something completely different than \ ic {' \ # (fa do
sol)}, and all the more \ ic {(vector fa do sol)}. We will return to this problem later.
\ seePage [assignment / sect: quotation], because, as you can see, not ~ so simple
Determine what exactly is the meaning of citing.


\ subsection {Branching} \ label {basics / evaluating-forms / ssect: alternatives}

\ indexC {if}
Recall how the conditional operator \ ic {if} works : this form calculates its own
the first argument ( \ term {condition}), then in ~ depending on the result of the calculations
selects, returns the value of the second argument ( \ term {effect}) or the third
( \ term {alternative}). This idea is expressed by the following code:

\ begin {code: lisp}
... (case (car e)
      ((if) (if (evaluate (cadr e) env)
                (evaluate (caddr e) env)
                (evaluate (cadddr e) env))) ...) ...
\ end {code: lisp}

\ indexR {representation of boolean values}
\ indexR {Boolean values}
This program does not exactly take into account the representation of logical values. Clearly
it can be seen that two languages ​​are mixed here: Scheme (or at least that "~ is indistinguishable
similar to it) and Scheme (or that "~ something pretty similar) .We also define
second in terms of the first. So between them there are about the same
relationship, as between Pascal (on which the first implementation is written ~ \ TeX ) and
by the system itself {{ TeX } \ cite {knu84}. Accordingly, there is no single reason
To consider ways of representation of logic values ​​in these languages ​​identical.

The function \ ic {evaluate} returns the values ​​of the specified language. They a priori no way
not ~ are associated with the logical values ​​of the language used for implementation. Following
agreement that ~ any object that is not equal to a logical \ term {lie} must
be considered logical \ term {truth}, we write:

\ begin {code: lisp}
... (case (car e)
      ((if (if (not (eq? (evaluate (cadr e) env) the-false-value))
                (evaluate (caddr e) env)
                (evaluate (cadddr e) env))) ...) ...
\ end {code: lisp}

\ indexC {the-false-value}
Here it is assumed that the variable ~ \ ic {the-false-value} stores the value \ term {lie}
defined language, expressed in terms of the defining language. Selection options
There are many such representations, for example, we do this:

\ begin {code: lisp}
(define the-false-value (cons "false" "boolean"))
\ end {code: lisp}

In this case everything will be fine, because \ ic {eq?} In ~ Scheme compares
not ~ values, and addresses, and, accordingly, any other value in any way it is impossible
will be confused with the value of the variable \ ic {the-false-value}.

\ indexC {()} \ indexC {NIL} \ indexR {empty list, \ protect \ ic {()}}
The question of representing logical values ​​is not at all trivial. In the history of Lisp
there is a lot of debate about the difference between the boolean value \ term {false}, empty
list ~ \ ic {()} and the symbol ~ \ ic {NIL}. The most clear position on this issue:
\ term {false} is not ~ \ ic {()} (in the end, it's just an empty list), and they
Both especially do not have anything to do with the character composed of letters
\ ic {N}, \ ic {I} and ~ \ ic {L}.

Scheme takes this position; About this ~ all the same could agree for a couple
weeks before the adoption of the standard ~ IEEE \ cite {iee91}.

So in ~ Scheme everything is fine now (except that \ ic {()} in English still
is read as ~ \ emph {nil}!). In the original Lisp \ term {lie}, \ ic {()} and ~ \ ic {NIL}
"--- this is the same character.In ~ { \ LeLisp } \ ic {NIL} this is the variable ω
value ~ \ ic {()}, and an empty list (along with the ~ blank character ~ \ ic {||})
is used as ~ \ term {lie}.


\ subsection {Sequence} \ label {basics / evaluating-forms / ssect: sequence}

\ indexC {begin} \ indexC {progn}
There is a special form that allows us to calculate a group of forms in series
and in a certain order. Like the old ~ good blocks \ ic {begin ... end} from
family of Algol languages, in ~ Scheme this form is called \ ic {begin}; in others
Lisp is usually called \ ic {progn} "--- the generalized version of \ ic {prog1},
\ ic {prog2} { \ itd } We organize the organization of the sequence ourselves
functions ~ \ ic {eprogn}.

\ indexC {eprogn}
\ begin {code: lisp}
... (case (car e)
      ((begin) (eprogn (cdr e) env)) ...) ...

(define (eprogn exps env)
  (if (pair? exps)
      (if (pair? (cdr exps))
          (begin (evaluate (car exps) env)
                 (eprogn (cdr exps) env))
          (evaluate (car exps) env))
      '()))
\ end {code: lisp}

This definition of successive calculations does not allow for discrepancies. It is worth
Pay attention to the tail recursion when calculating the last form
sequence. The calculations are constructed so that the last call \ ic {evaluate}
replaces the entire recursive chain of calls \ ic {eprogn}. (O ~ tail
We will talk more about recursion later.
\ seePage [escape / pr-cont / ssect: tail-recusion])

\ indexCS {begin} {return value}
\ indexR {return values ​​of! form (begin) @ form \ protect \ ic {(begin)}}
\ indexC {empty-begin}
Another interesting point is that \ ' {o} is returned when calculating
form \ ic {(begin)}. Now this is an empty list. But why exactly \ ic {()}, why
not ~ what ~ something else, like \ ic {: 3} or \ ic {( \ nya )}? We chose an empty list by
The habit inherited from Lisp: in any incomprehensible situation
return \ ic {nil}. But in a world where \ term {false}, \ ic {nil} and ~ \ ic {()} "is this
completely different things, which one is better suited for the role of \ emph {nothing}?
Therefore, in our language, let the calculation of \ ic {(begin)} return a special
the value of \ ic {empty-begin}, which is defined as (almost) a random number
\ ic {813} ~ \ cite {leb05}.

\ indexC {eprogn} \ indexC {empty-begin}
\ begin {code: lisp}
(define (eprogn exps env)
  (if (pair? exps)
      (if (pair? (cdr exps))
          (begin (evaluate (car exps) env)
                 (eprogn (cdr exps) env))
          (evaluate (car exps) env))
      empty-begin))

(define empty-begin 813)
\ end {code: lisp}

\ indexR {syntax! begin @ \ ic {(begin)}}
\ indexC * {unspecified} { \ # <unspecified>}
The root of our problem is that \ ic {begin} \ emph {must} return some "~ then
value. Like Scheme, a definable language can not ~ impart any meaning
form \ ic {(begin)}; We can either allow such writing and return any
a convenient value, or ~ the same does not ~ admit and consider an error. Perfect option:
generally do not use \ ic {begin} without arguments, since it is not defined that
it will turn out in the result. Some implementations have a special object:
\ ic { \ # <<unspecified>}, which is returned in the case where there is nothing more
suitable. Usually the only thing that can be done with it "is to output this to
printing. (He ~ it is necessary to confuse this object with a ~ pseudo-value of ~ undefined
variables. \ seePage [lisp1-2-omega / recusion / ssect: uninitialized])

\ bigskip

\ indexR {language! purely functional}
\ indexR {side effects}
Consecutive calculation of expressions is useless in purely functional languages
(where the functions do not have side effects). Indeed, in what case
meaning that "~ then calculate and do not ~ use the return values? But sometimes
in ~ this may be the point. Imagine a game written purely
functional language; It is obvious that the calculations take some time
regardless of whether their results are used or not; and we can
interest is precisely this "side effect >>" --- slowing down the work, "--- a
not ~ the results obtained. Then we can successively "calculate something,
for example, that the speed of the game is adequate to the player's reflexes (if only
the compiler does not ~ consider itself to be the smartest and will not ~ delete the "useless" code).

\ indexCS {begin} {need}
Since there are I / O operations in ~ Scheme that have side effects, then
for us it makes sense to use the form \ ic {begin}, because it is obvious that
it is better to first ask the question (with the help of \ ic {display}), and then read the answer
(with the help of \ ic {read}), than do the reverse. Here "~ that's exactly what you need
order the calculations. But not only \ ic {begin} can order them.
For example, a conditional statement can:

\ begin {code: lisp}
(if | $ \ alpha $ | | $ \ beta $ | | $ \ beta $ |) | \ eq | (begin | $ \ alpha $ | | $ \ beta $ |)
\ end {code: lisp}

\ phantomlabel {basics / forms / sequence / par: gensym-puzzle}
\ noindent
And ~ \ ic {lambda} can also \ footnote {The variable \ ii {void} should not be ~ free
in the $ \ beta $ . This condition is met if \ ii {void} never occurs
in the $ \ beta $ . Usually in this case, \ ic {gensym} is used to get
guaranteed unique variable name. \ seeEx [basics / ex: no-gensym]}:

\ begin {code: lisp}
(begin | $ \ alpha $ | | $ \ beta $ |) | \ eq | ((lambda (| \ ii {void} |) | $ \ beta $ |) | $ \ alpha $ |)
\ end {code: lisp}

As you can see from this example, in ~ Scheme \ ic {begin} not ~ is necessary
special form, as its behavior can be emulated with help
functions by the fact that when a function is called, its arguments are evaluated before
execution of the body (passing arguments \ term {by value}).


\ subsection {Assignment} \ label {basics / evaluating-forms / ssect: assignment}

\ indexC {set "!}
\ indexR {assignment}
\ indexR {naming convention! side effects}
As in many other languages, in our dialect the values ​​of the variables can be
change. Changing the value of a variable is called \ term {assignment}. As
the value of the variable must be changed in its environment, then we leave this problem
function ~ \ ic {update!}. \ footnote * {In accordance with the ~ agreement in ~ Scheme,
function names with side effects end in an exclamation mark.} Its
The real essence is explained later, on
page ~ \ pageref {assignment / implementation / ssect: environment}.

\ begin {code: lisp}
... (case (car e)
      ((set!) (update! (cadr e) env
                       (evaluate (caddr e) env))) ...) ...
\ end {code: lisp}

Assignment is performed in ~ two steps: first the new value is calculated, then
The new value replaces the old one. It is worth noting that the updated variable
not ~ is the value of this form. We will return to the question of return
value of the assignment operation. \ seePage [chapter: assignment] Currently only
remember that it is not defined by the standard.


\ subsection {Abstraction} \ label {basics / evaluating-forms / ssect: abstraction}

\ indexR {abstraction}
Functions (also called \ term {procedures} in ~ Scheme) are the result
calculation of the special form \ ic {lambda}, whose name refers to the concept
\ term {abstraction} in ~ $ \ lambda $ "= calculus.
we assign functions ~ \ ic {make-function}, to which we pass all necessary: ​​list
arguments, the function body, and the current environment.

\ begin {code: lisp}
... (case (car e)
      ((lambda) (make-function (cadr e) (cddr e) env)) ...) ...
\ end {code: lisp}


\ subsection {Application} \ label {basics / evaluating-forms / ssect: application}

\ indexR {application}
\ indexR {combination}
\ indexR {term! function}
\ indexR {functional term}
If the first element of the list is not a special operator, then such a list
means the application of a function that in the $ \ lambda $ "= calculus is called
\ term {application} or \ term {combination}. The function obtained in the result
the calculation of the first element, is applied to the arguments that we get,
calculating the remaining elements of the list. These actions are described by the following code:

\ begin {code: lisp}
... (case (car e)
      (else (invoke (evaluate (car e) env)
                    (evlis (cdr e) env)))) ...
\ end {code: lisp}

The helper function ~ \ ic {evlis} takes a list of expressions and returns
a list of the corresponding values. It is defined as follows:

\ indexC {evlis}
\ begin {code: lisp}
(define (evlis exps env)
  (if (pair? exps)
      (cons (evaluate (car exps) env)
            (evlis (cdr exps) env))
      '()))
\ end {code: lisp}

Then the function ~ \ ic {invoke} works , which applies its first argument
(function; if it is not ~ so, it reports an error) to the second (list of it
arguments) and returns the result of the calculations. In general, \ ic {invoke} is similar to
habitual \ ic {apply}, unless it requires an explicit indication of the environment. (Further
in the ~ section \ ref {basics / sect: representing-functions}
\ seePage [basics / sect: representing-functions] we will consider in more detail uneasy
relationships between functions and environments.)


\ subsubsection { \ texorpdfstring {More ~ ​​little about ~ \ protect \ ic {evaluate}} %
{A little more about evaluate}}

\ indexR {order of calculation! of terms of application}
The described description of the language is more or less precise. We did not disassemble only
several auxiliary functions: \ ic {lookup} and \ ic {update!}, responsible for
environment, and \ ic {make-function} along with the \ ic {invoke}, dealing with functions.
But even now we already know a lot about ~ \ ic {evaluate}. For example, our dialect
has a single namespace, the concept of an object in it extends in general
on everything (as in ~ \ Lisp 1 \ seePage [chapter: lisp1-2-omega]), including functions.
But we still do not know how to calculate the arguments.

In our case, it depends on the order of computing the arguments y ~ \ ic {cons}, which
is used in ~ \ ic {evlis}. But we can easily indicate any we like
order, for example, from left to right:

\ begin {code: lisp}
(define (evlis exps env)
  (if (pair? exps)
      (let ((argument1 (evaluate (car exps) env)))
        (cons argument1 (evlis (cdr exps) env)))
      '()))
\ end {code: lisp}

Without the introduction of new special constructions \ footnote {As is known, \ ic {let} "---
it's just a simple macro: \ ic {(let (( $ x $  $ \ pi _ 1 $ )) $ \ pi _ 2 $ )} { \ eq }
\ ic {((lambda ( $ x $ ) $ \ pi _ 2 $ ) $ \ pi _ 1 $ )}.} we specified the behavior of the
language. The first part of the book is aimed precisely at this: clarification of the
language with the help of increasingly limited capabilities, which reduces the dependence
description of the language used to determine.


\ section {Representing Environments} \ label {basics / sect: repr-the-env}

\ indexE {A-list} \ indexR {A-list}
\ indexR {associative list}
Environments connect variables with their values. Usually in Lisp such connections
are represented by \ term {associative lists}, also called
\ term {A-lists}. We, too, will represent the environment as ~ A-lists,
binding variables and values. For simplicity, the names of the variables are
represent by symbols.

Thus, the functions \ ic {lookup} and \ ic {update!} Are defined elementary:

\ ForLayout {display} { \ begingroup
\ lstset {aboveskip = \ smallskipamount , belowskip = \ smallskipamount }}

\ indexC {lookup}
\ begin {code: lisp}
(define (lookup id env)
  (if (pair? env)
      (if (eq? (caar env) id)
          (cdar env)
          (lookup id (cdr env)))
      (wrong "No such binding" id)))
\ end {code: lisp}

Here we see the second type \ footnote {First "--- these are syntax errors
(page ~ \ pageref {basic / atoms / para: the-first-error}).} Possible errors,
When you try to find out the value of an unknown variable. We are again only
call \ ic {wrong} to report the problem to the top.

\ indexR {autocycling}
When the computers were large and the memory was small, \ footnote * {Memory
(along with ~ I / O subsystems) is still one of the most expensive
parts of the computer, though constantly becoming cheaper.} for variables,
\ term {autocytics}. If a value is associated with a variable,
then the value with the name of the variable became that value. It would be very disappointing
To see how the concepts of variable and symbol, which we so zealously shared,
again mixed and mixed up.

Although this is undoubtedly convenient "--- never ~ cause errors, but such an ideal
The world has a big drawback: the task of the program is not to work without
errors, but in order to perform what it is intended for. In this sense
mistakes play the role of a handrail: if we stumble upon them, it means we are going
where "~ then not ~ there." Errors should be detected as early as possible so that both
you can fix them faster. Consequently, the use of autocytotation "---
a bad decision, because it hides some errors that could have been
corrected earlier.

The ~ \ ic {update!} Function changes the environment, so it's likely that it can also
cause the same error: you can not change the value of an unknown variable. we
we will discuss whether it should be so when we talk about the global
surrounded by.

\ indexC {update "!}
\ begin {code: lisp}
(define (update! id env value)
  (if (pair? env)
      (if (eq? (caar env) id)
          (begin (set-cdr! (car env) value)
                 value)
          (update! id (cdr env) value))
      (wrong "No such binding" id)))
\ end {code: lisp}

\ ForLayout {display} { \ endgroup }

\ indexCS {set "!} {return value}
\ indexR {assignment! return value}
\ indexR {return assignment values}
The return value of the function ~ \ ic {update!} Was chosen with the account that this
value becomes the value of the entire assignment expression. In ~ Scheme this value
not ~ defined. Strictly speaking, programs should not rely on any "~
meaning, but, nevertheless, we are forced to choose what exactly we will return
in our case. For example:

\ begin {enumerate}
  \ item the value just assigned (as done now);

  \ item the previous value of the variable (there may be problems
        with initialization, first assignment);

  \ item  \ indexC * {UFO} { \ # <UFO>} \ label {basics / s: env / ufo}
        the object is "indefinite", some \ ic { \ # <UFO>},
        used exclusively as an indicator of uncertain
        values;

  \ item value of the form with an undefined value, like
        \ ic {set-cdr!} in ~ Scheme.
\ end {enumerate}

\ indexR {environment! as data type}
Environments "is a composite abstract data type .We can already extract and
to change their parts with the help of the corresponding functions; But still need to be able to
Create new environments and add new parts to them.

\ indexR {environment! initial}
Initially, there is nothing in the environment. This is written simply:

\ indexC {env.init}
\ begin {code: lisp}
(define env.init '())
\ end {code: lisp}

(A little later, in the section \ ref {basics / sect: representing-functions}, we'll make it
not so uninhabited.)

When a function is called, a new environment is created for it, in which it
the arguments are related to their actual values. The function ~ \ ic {extend}
extends the environment ~ \ ic {env} with variables \ ic {variables} with the corresponding
values ​​of ~ \ ic {values}.

\ indexC {extend}
\ begin {code: lisp}
(define (extend env variables values)
  (cond ((pair? variables)
         (if (pair? values)
             (cons (cons (car variables) (car values))
                   (extend env (cdr variables) (cdr values)))
             (wrong "Too few values")))
        ((null? variables)
         (if (null? values)
             env
             (wrong "Too many values")))
        ((symbol? variables) (cons (cons variables values) env))))
\ end {code: lisp}

\ indexR {argument list}
\ indexR {syntax of argument list}
\ indexR {variables}
\ indexR {point variables}
The main difficulty is that we need to analyze all the options
records of the < \ ii {argument list}> that are allowed in ~ Scheme. \ footnote * {Some
Lisp systems, like \ CommonLisp , succumbed to the temptation to expand the syntax of the list
arguments with keywords like \ ic { \ & aux}, \ ic { \ & key}, \ ic { \ & rest}. But this
greatly complicates the parsing and binding. Other systems allow even
generic specification of arguments using templates ~ \ cite {sj93}.} List
arguments can be represented not only by a normal list of symbols, but also by
point: end up not ~ on ~ \ ic {()}, but on a certain character
( \ term {point variable}). More formally, the list of arguments is described
the following grammar:

\ begin {center} \ setlength { \ tabcolsep } {2pt} \ begin {tabular} {rcl}
  < \ ii {argument list}> & :: = & \ ic {()}                                   \\
                           & | & < \ ii {variable}>                         \\
                           & | & \ ic {({ \ normalfont < \ ii {variable}>}
                                    . { \ normalfont < \ ii {argument list}>})} \\
         < \ ii {variable}> & $ \ in $ & \ Vset {Characters}
\ end {tabular} \ end {center}

When we expand the environment, the number of variable values ​​must
correspond to the number of their names. Usually they are equally divided, but if the list
ends with a point (or ~ \ term {n "~ aryna)) variable, it is bound
with a list of all the remaining arguments. As it were, there are two possible errors:
or values ​​greater than variables, or vice versa.


\ section {Representing functions} \ label {basics / sect: representing-functions}

Perhaps the easiest way to represent functions with functions. Naturally, this
not a tautology, and read as follows: << the functions of the language being defined are the easiest
represent functions of the language of definition >>. This greatly simplifies the call mechanism:
the function ~ \ ic {invoke} should only test whether its first argument is valid
is a function: than "~ what can be called.

\ indexC {invoke}
\ begin {code: lisp}
(define (invoke fn args)
  (if (procedure? fn) (fn args)
      (wrong "Not a function" fn)))
\ end {code: lisp}

It's harder to put it. Even the question may arise, why do we need a separate
function, when all this code could be built right into ~ \ ic {evaluate}. Cause,
on which this is done, in the fact that we show the structure of future
interpreters, and in them \ ic {invoke} will no longer be so simple. By the way,
try now to do the exercises ~ \ ref {basics / ex: def-call / cc}
and ~ \ ref {basics / ex: def-apply}.

\ indexR {application! order of calculating terms}
\ indexR {order of calculation! of terms of application}
Also, we have a new type of error that occurs when trying to call
unavailable. Now we are processing such errors at the time of application of the function
to ~ already computed arguments, but we could ~ warn the user before.
In this case, we need to specify the order of calculation of the elements of the call form
functions:

\ begin {enumerate}
  \ item calculate the element in place of the function;

  \ item if it is not a function, report an error;

  \ item evaluate the arguments from left to right;

  \ item compare the number of arguments with function arity
        and if they do not match, then report an error.
\ end {enumerate}

Calculating arguments from left to right seems logical for people reading on the left
right. This is easier to program, in the end, the order is simple and straightforward.
Complexities arise only in the compiler, because if he wants to change
This order (for example, to use the processor registers more efficiently), then
he will be forced to prove that this will not change the meaning of the program.

Of course, we could act more efficiently, checking arness even earlier:

\ begin {enumerate}
  \ item calculate the element in place of the function;

  \ item if it is not a function, report an error, otherwise remember the expected
        number of arguments;

  \ item evaluate arguments from left to right until their number
        is consistent with the arity of the function, in case of problems, report an error;

  \ item apply the function to arguments. \ footnote * {The function could then
        still check for the correctness of the types of arguments passed, but this
        not ~ has a relationship to the call mechanism.}
\ end {enumerate}

The { \ CommonLisp } standard requires that arguments be evaluated strictly on the left
to the right, but with the purpose of optimization it allows us to calculate the functional element
list before or after the rest.

Scheme ~ does not impose conditions on the order of calculation of all elements of the form
function call, including the function element itself. Since there are no restrictions, then
the compiler is free to choose any order that suits it.
\ seePage [denotational / sect: eval-order] A ~ user, in turn, can not ~
calculate a certain order of calculations and must use
\ ic {begin} to specify the required order explicitly.

It is considered a bad style to use function calls to get side-by-side
effects in the desired sequence. Therefore, expressions like
\ ic {(f (set! f $ \ pi $ ) (set! f $ \ pi ' $ ))}, where it is not clear which function will be
is called in fact. Errors that arise in such cases are very difficult
to catch.


\ subsection * {Enforcement environment of ~ functions}

\ indexR {environment! of the execution of the body function}
The application of the function is reduced to the calculation of the expressions that make up its body,
in an environment where the arguments of the function are associated with the values ​​passed in the call
function. Remember that when we called \ ic {make-function}, we passed everything
necessary for this, in the \ ic {evaluate} order. In the remaining
part of this section, we will disassemble the environment used for computing,
in ~ programs they will be typed \ ii {italics}.


\ subsubsection {Minimal environment}

First, let's look at the minimal possible environment:

\ indexC {make-function}
\ begin {code: lisp}
(define (make-function variables body env)
  (lambda (values)
    (eprogn body (extend | \ ii {env.init} | variables values))))
\ end {code: lisp}

\ indexE {K @ \ protect \ comb {K}, combinator}
\ indexR {combinators! K @ \ protect \ comb {K}}
In strict accordance with the previously described agreement, the function body is computed
in an environment where the arguments of the function are associated with the values ​​passed. For example,
having received in the result of a call \ ic {make-function} the combinator ~ \ comb {K}, defined
as \ ic {(lambda (a ~ b) a)}, we can call it as follows:

\ begin {code: lisp}
(K 1 2) | \ is | 1
\ end {code: lisp}

But there is also a nuisance: the function can only use its arguments and
local variables, because we defined \ ii {env.init} as empty
environment. In ~ it does not even have basic functions from a global environment like
\ ic {car} or \ ic {cons}.


\ subsubsection {Improved environment}

Well, let's try to improve our definition as follows:

\ begin {code: lisp}
(define (make-function variables body env)
  (lambda (values)
    (eprogn body (extend | \ ii {env.global} | variables values))))
\ end {code: lisp}

Remarkably, now our functions have access to the ~ global environment and all
its functions. And what if we try to define mutually recursive functions?
Also, what result will the program give to the left (on the right it is the same with the ~ opened
macros)?

{ \ def \ E { \ hbox to 0pt { \ kern 0.3em $ \ equals $ }}
\ begin {code: lisp}
(let ((a 1)) ((lambda (a)
  (let ((b (+ 2 a))) ((lambda (b)
    (list ab))) | \ E | (list ab))
                            (+ 2 a)))
                         1 )
\ end {code: lisp}}

Let's look at the steps, how this expression is evaluated:

\ begin {code: lisp}
((lambda (a) ((lambda (b) (list ab)) (+ 2 a))) 1) | \ begin {where}
                                                   \ -  \ ii {env.global}
                                                   \ end {where} |
| | \ equals | ((lambda (b) (list ab)) (+ 2 a)) | \ begin {where}
                                            \ - a { \ is } 1
                                            \ -  \ ii {env.global}
                                            \ end {where} |
| | \ equals | (list ab) | \ begin {where}
                     \ - b { \ is } 3
                     \ -  \ ii {env.global}
                     \ end {where} |
\ end {code: lisp}

The body of the inner function \ ic {(lambda (b) (list a ~ b))} is executed in an environment,
obtained by extending the global environment variable ~ \ ic {b}. That's right. But
in this environment there is no necessary variable ~ \ ic {a}!


\ subsubsection {Improved environment (second attempt)}

Since we need to see the variable ~ \ ic {a} in the internal function, it is sufficient
will pass \ ic {invoke} the current environment, and it will in turn transfer it
called function. To realize this idea, it is necessary to correct a little
\ ic {evaluate} and \ ic {invoke}; so as not to confuse these definitions with previous ones,
let them start at ~ \ ic {d.}:

\ indexC {d.evaluate}
\ indexC {d.invoke}
\ indexC {d.make-function}
\ begin {code: lisp}
(define (d.evaluate e env)
  (if (atom? e) ...
      (case (car e)
        ...
        ((lambda) (d.make-function (cadr e) (cddr e) env))
        (else (d.invoke (d.evaluate (car e) env)
                            (evlis (cdr e) env)
                            env)))))

(define (d.invoke fn args env)
  (if (procedure? fn)
      (fn args env)
      (wrong "Not a function" fn)))

(define (d.make-function variables body | \ ii {def.env} |)
  (lambda (values ​​| \ ii {current.env} |)
    (eprogn body (extend | \ ii {current.env} | variables values))))
\ end {code: lisp}

In this definition, it should be noted that passing the environment of the definition \ ic {env}
through the variable ~ \ ii {def.env} is meaningless, since only
current environment \ ii {current.env}.

\ indexR {call stack}
Let's take another look at the example above. Now the variables
do not disappear:

\ begin {code: lisp}
((lambda (a) ((lambda (b) (list ab)) (+ 2 a))) 1) | \ begin {where}
                                                   \ -  \ ii {env.global}
                                                   \ end {where} |
| | \ equals | ((lambda (b) (list ab)) (+ 2 a)) | \ begin {where}
                                            \ - a { \ is } 1
                                            \ -  \ ii {env.global}
                                            \ end {where} |
| | \ equals | (list ab) | \ begin {where}
                     \ - b { \ is } 3
                     \ - a { \ is } 1
                     \ -  \ ii {env.global}
                     \ end {where} |
\ end {code: lisp}

At the same time, we explicitly see the \ emph {call stack}: each binding form first
puts its new variables on top of the current environment, and then removes them
from there after the end of the calculations.


\ subsubsection {Fix the problem}

But even with this definition, there are still problems. Consider the following
example:

\ begin {code: lisp}
((((lambda (a)
     (lambda (b) (list ab)))
  1 )
 2)
\ end {code: lisp}

The function ~ \ ic {(lambda (b) (list a ~ b))} is created in an environment where \ ic {a} is bound
with the value ~ \ ic {1}, but in the moment of the call in the environment will be present
only ~ \ ic {b}. Thus, we again lost the variable ~ \ ic {a}.

No doubt, you noticed that in the definition of \ ic {d.make-function} there are
two environments: the definition environment \ ii {def.env} and the execution environment
\ ii {current.env}. There are two important events in the life of a function: its creation and
her ~ challenge (s). Obviously, a function is created only once, and can be called
repeatedly; or never ~ be called at all. Consequently,
The only \ footnote {In fact, here you can use whatever you need
environment. See ~ about the form ~ \ ic {closure} on
page ~ \ pageref {assignement / assignement / para: closure}.} The environment that we
can uniquely be associated with a ~ function, "is the environment in which it was
created. We return to the initial definitions of the functions \ ic {evaluate} and \ ic {invoke},
but in ~ this time the function ~ \ ic {make-function} is written as follows:

\ indexC {make-function}
\ begin {code: lisp} [label = basics / representing-functions / fixing / src: inject-current-env]
(define (make-function variables body | \ ii {env} |)
  (lambda (values)
    (eprogn body (extend | \ ii {env} | variables values))))
\ end {code: lisp}

Now all the above examples work fine. In particular, the example above
is calculated as follows:

\ begin {code: lisp}
(((lambda (a) (lambda (b) (list ab))) 1) 2) | \ begin {where}
                                             \ -  \ ii {env.global}
                                             \ end {where} |
| | \ equals | ((lambda (b) (list ab)) | \ begin {where}
                                   \ - a { \ is } 1
                                   \ -  \ ii {env.global}
                                   \ end {where} |
    2) | \ begin {where}
        \ -  \ ii {env.global}
        \ end {where} |
| | \ equals | (list ab) | \ begin {where}
                     \ - b { \ is } 2
                     \ - a { \ is } 1
                     \ -  \ ii {env.global}
                     \ end {where} |
\ end {code: lisp}

\ indexR {abstraction! closure}
\ indexR {abstraction! value}
\ indexR {return values ​​of! abstractions}
\ indexR {closures}
The form \ ic {(lambda (b) (list a ~ b))} is created in a ~ global environment expanded
variable ~ \ ic {a}. When this function is called, it expands its
creating the variable ~ \ ic {b}, so the body of the function will be computed
in an environment where both the variables \ ic {a} and ~ \ ic {b} are present. After
the function returns the result, the execution continues in the global environment. we
we will call the value of abstraction \ term {closure} (closure), because when
the body of the function becomes closed in the environment of its own
definition.

It is worth noting that now \ ic {make-function} itself uses language closures
definition. This is not ~ mandatory, as we will show later in the third chapter.
\ seePage [escape / actors / ssect: functions] The function \ ic {make-function} returns
closure, and this "is a characteristic feature of functional programming languages.


\ subsection {Dynamic and lexical scope ~ visibility} %
\ label {basics / representing-functions / ssect: dynamic-and-lexical-binding}

Two conclusions can be drawn from this conversation about environments. First, it is clear,
that with environments not everything is that simple. Any calculation is always done
in what "environment, therefore, it is necessary to effectively implement them
using. The third chapter deals with more complex things like
unwrapping the stack and the corresponding ~ \ ic {unwind-protect} form , which will require
from us even more accurate control over the environment.

\ indexR {lexical binding} \ indexR {dynamic binding}
\ indexR {link! lexical} \ indexR {link! dynamic}
\ indexR {Lisp lexical} \ indexR {Lisp dynamic}
The second point is related to the ~ two variants considered in the previous section,
which are examples of \ term {lexical} and \ term {dynamic
binding} \ footnote {In the "object" = oriented languages ​​under dynamic
binding is usually understood as the mechanism for selecting an object's method based on its
real type during the execution of the program, in contrast to the static
binding, in which the method is selected by the compiler based on the type of the variable,
which stores the object under consideration.} (The terms lexical and
dynamic scope). In ~ \ emph {lexical} Lisp, the function is executed
in the environment of his definition, extended by his own variables, whereas
in ~ \ emph {dynamic} "--- expands the current environment, the environment of its call.

Now in the mode of lexical binding, but this does not mean that there is no dynamic linkage
future. On the one hand, it is the dynamic binding that is applied
in some fairly popular languages ​​like \ TeX ~ \ cite {knu84},
Emacs ~ Lisp \ trnote {Starting with ~ Emacs ~ Lisp v. \, 24 and Perl ~ 5, these languages ​​have and
lexical variables.} ~ \ cite {llst93}, Perl ~ \ cite {ws91}.

On the other hand, the very idea of ​​a dynamic scope is important
concept of programming. It corresponds to the installation of links before
execution of calculations and guaranteed automatic deletion of these links
after completion of calculations.

\ indexR {exceptions}
\ indexR {search with return}
Such a strategy can be effectively applied, for example, in an artificial
intellect. In this case, first a hypothesis is put forward, then from it
effects are produced. Once the system comes across a contradiction, then
The hypothesis should be rejected and go to the next one. This is called \ term {search
with ~ return}. If the consequences of the hypotheses are stored without the use of side effects
effects, for example, in ~ A-lists, then rejecting the hypothesis automatically and without
problems and recovers all of its consequences. But if this is used
global variables, arrays { \ itd }, then for an unnecessary hypothesis
it takes a long time to clean up, remembering what the state of memory was at the time
hypotheses and what parts of it can be rolled back to old values, so that
nothing ~ break! Dynamic scope allows you to guarantee
the existence of a variable with a certain value for ~ time and only at the time
calculations, regardless of whether they are successful or not. This property is also
It is widely used when handling exceptions.

\ indexR {scope}
\ term {Scope} of a variable "is --- it can be said, geographic
concept in the program: locality where the variable occurs and it can be
use. In a ~ pure Scheme (not burdened with useful, but not ~ absolutely
necessary things like ~ \ ic {let}) there is only one binding form:
\ ic {lambda}. This is the only form that introduces new variables and provides
their scope within the framework of the function being defined. In the dynamic Lisp
the scope in principle can not be limited by a function. Consider
the following example:

\ begin {code: lisp}
(define (foo x) (list xy))
(define (bar y) (foo 1991))
\ end {code: lisp}

In lexical Lisp, the variable ~ \ ic {y} in ~ \ ic {foo} \ footnote {About the origin
\ emph {foo} see ~ \ cite {ray91}.} "is always a reference to the global
variable ~ \ ic {y}, which has nothing to do with ~ \ ic {y} inside ~ \ ic {bar}.
In the ~ dynamic Lisp variable, the variable \ ic {y} from \ ic {bar} will be visible in ~ \ ic {foo}
inside \ ic {bar}, because at the time of the call \ ic {foo} the variable ~ \ ic {y} is already
was in the current environment. Therefore, if we give a global \ ic {y}
the value of ~ \ ic {0}, then we get the following results:

\ begin {code: lisp}
(define y 0)
(list (bar 100) (foo 3)) | \ is | ((1991 0) (3 0)); in lexical Lisp
(list (bar 100) (foo 3)) | \ is | ((1991 100) (3 0)); in a ~ dynamic Lisp
\ end {code: lisp}

\ indexR {free variables! and scopes}
Note that in the ~ dynamic Lisp \ ic {bar} concept has no ~ that
in ~ \ ic {foo} its local variable ~ \ ic {y} is used, and ~ \ ic {foo} does not know
About what environment it is necessary to search for value of the free
variable ~ \ ic {y}. Simply \ ic {bar} on call put in the ~ current environment
variable ~ \ ic {y}, and the internal function \ ic {foo} found it in its ~
the current environment. Immediately before the exit, \ ic {bar} will remove its ~ \ ic {y} from
environment, and the global variable ~ \ ic {y} will again be visible.

Of course, if you do not ~ use free variables, then there is not much difference between
dynamic and lexical scopes.

Lexical binding got its name because in this case it is enough
have only the function code to reliably relate each used in ~ it
variable to one of two classes: either the variable is inside the binding
form and is local, or ~ it is a global variable. This is extremely
simply: just take the source code, take a pencil (or mouse) and put
its tip on the variable, the value of which we are interested in, and then follows
lead the pencil from right to left, from bottom to top until we meet the first
binding form. Dynamic linking is named in honor of the concept
\ term {dynamic lifetime} of variables, which we will consider
later. \ seePage [escape / forms / ssect: dynamic]

Scheme supports only lexical variables. { \ CommonLisp } supports
Both types have the same syntax. The syntax { \ EuLisp } and { \ ISLisp } separates these
two types of variables, and they are in ~ separate namespaces.
\ seePage [lisp1-2-omega / sect: namespaces]

\ indexR {scope! name conflict}
\ indexR {variables! hiding names}
\ indexR {hiding variables}
\ indexR {hiding variables | seealso {scopes}}
The scope of the variable may be interrupted. This happens when one
the variable \ term {hides} the other from "~ because both have the same name.
Lexical scopes are embedded in each other, hiding the variables
with ~ coinciding names from outside areas. This well-known "blocking"
the order of conflict resolution is inherited from Algol ~ 60.

Under the influence of $ \ lambda $ "= calculus, in whose honor the special
the form \ ic {lambda} ~ \ cite {per79}, \ LISP ~ 1.0 was made dynamic, but soon
John ~ McCarthy realized what he expected to get from the following expression
\ ic {(2 ~ 3)}, and not ~ \ ic {(1 ~ 3)}:

\ begin {code: lisp}
(let ((a 1))
  ((let ((a 2)) (lambda (b) (list ab)))
   3))
\ end {code: lisp}

\ indexCS {function} {for closures}
\ indexCS {lambda} {as a keyword}
This anomaly (I do not dare call it a mistake) has been corrected by the introduction of a new
special form ~ \ ic {function}. She took the \ ic {lambda} -form and created
\ term {closure} "is a function associated with the environment in which it is defined.
When the closure was called, the environment expanded instead of the current environment
definitions, closed inside it. Together with the changes \ ic {d.evaluate} and
\ ic {d.invoke}, form ~ \ ic {function} \ footnote {Our simulation is not exactly accurate, so
as there are many Lisp dialects (like CLtL1 ~ \ cite {ste84}), where
\ ic {lambda} "is not a special operator, but only a keyword marker
like \ ic {else} inside \ ic {cond} and \ ic {case}. In this case, \ ic {d.evaluate}
can not know ~ about any \ ic {lambda} at all. Sometimes even overlap
restrictions on the position of \ ic {lambda} -forms, allowing them to be only
inside \ ic {function} and in function definitions.} is expressed thus:

\ indexC {d.invoke} \ indexC {d.make-function} \ indexC {d.make-closure}
\ begin {code: lisp} [label = basics / repr-func / dyn-and-lex-bind / src: closure-eval]
(define (d.evaluate e env)
  (if (atom? e) ...
      (case (car e)
        ...
        ((function); Syntax: \ ic {(function (lambda \ ii {arguments} \ ii {body}))}
         (let * ((f (cadr e))
                (fun (d.make-function (cadr f) (cddr f) env)))
           (d.make-closure fun env)))
        ((lambda) (d.make-function (cadr e) (cddr e) env))
        (else (d.invoke (d.evaluate (car e) env)
                            (evlis (cdr e) env)
                            env)))))

(define (d.invoke fn args env)
  (if (procedure? fn)
      (fn args env)
      (wrong "Not a function" fn)))

(define (d.make-function variables body env)
  (lambda (values ​​current.env)
    (eprogn body (extend current.env variables values))))

(define (d.make-closure fun env)
  (lambda (values ​​current.env)
    (fun values ​​env)))
\ end {code: lisp}

\ indexR {special variables}
\ indexC {special}
But this is not the end of the whole story. \ ic {function} "is just a crutch, on
which was based on the lame implementation of Lisp. With ~ the creation of the first compilers has become
It is clear that from the point of view of productivity in a lexical field of view, there is
(expected at compilation) advantage: it is possible to generate the code for more or less
direct access to ~ any variable, and not ~ dynamically retrieve its value
anew each time. Then by default they began to make all variables lexical,
except for those that were explicitly labeled as dynamic or, as then
they were called \ term {special}. The expression \ ic {(declare (special ~ \ ii {x}))}
was the command of the compilers \ LISP ~ 1.5, \ CommonLisp , Maclisp and ~ others,
saying that the variable ~ \ ii {x} behaves "especially".

\ indexR {reference transparency}
Efficiency was not the only reason for such a decision. Other
the reason was the loss of \ term {referential transparency} ( \ english {referential
transparency}). Reference transparency "is a property of the language,
in that the replacement in the program of any expression by its equivalent does not change anything
behavior of this program (both versions of the program or return the same thing
value, or together stuck in an infinite loop). For example:

\ begin {code: lisp}
(let ((x (lambda () 1))) (x)) | \ eq | ((let ((x (lambda () 1))) x)) | \ eq | 1
\ end {code: lisp}

In the general case, reference transparency is lost if the language allows side
effects. To keep it and with side effects, it is necessary
more precisely define the concept of equivalent expressions. Scheme has a reference
transparency, if not ~ use assignments, functions with side effects
and continuation. \ seeEx [escape / ex: crazy-cc] This property is desired in our
programs, if we want to make them really reusable, like
can be less dependent on the context of use.

\ indexR {variables! nameless}
\ indexR {alpha @ $ \ alpha $ -conversion}
Local variables of functions like \ ic {(lambda (u) (+ ~ u ~ u))} are sometimes called
\ emph {nameless}. Their names mean nothing and can be absolutely
arbitrary. The function \ ic {(lambda (n347) (+ ~ n347 ~ n347))} "is the same
most \ footnote {In terms of $ \ lambda $ "= calculus, a similar name substitution is called
$ \ alpha $ "= conversion.} a function such that \ ic {(lambda (u) (+ ~ u ~ u))}.

We expect that this invariant will remain in ~ language. But this is impossible
in a ~ dynamic Lisp. Consider the following example:

\ indexC {map}
\ begin {code: lisp}
(define (map fn l); or \ ic {mapcar}, as anyone likes
  (if (pair? l)
      (cons (fn (car l)) (map fn (cdr l)))
      '()))

(let ((l '(abc)))
  (map (lambda (x) (list-ref lx))
       '(2 1 0)))
\ end {code: lisp}

(The function ~ \ ic {(list-ref $ \ ell $  \ ii {n})} returns the \ ii {n} "~ th ~ element
list ~ $ \ ell $ .)

In ~ Scheme we would get \ ic {(cba)}, but in dynamic Lisp, the result is
\ ic {(0 0 0)}! Reason: the free variable ~ \ ic {l} in the function \ ic {(lambda (x)
(list-ref lx))}, whose name is already occupied by the local variable ~ \ ic {l}
in ~ \ ic {map}.

This difficulty can be solved simply by changing the conflicting names. For example,
it will suffice to rename one of the two ~ \ ic {l}. For example,
which is inside \ ic {map}, because it is more reasonable. But what name to choose,
so that this problem does not arise again? If you assign in front to the ~ name of each
variable number of the programmer's passport, and behind "--- current \ UNIX- time, then
this, of course, will significantly reduce the likelihood of collisions, but the readability of programs
will leave much to be desired.

In the early eighties there was a rather unpleasant situation: students
Lispu was taught by the example of interpreters, but their understanding of scopes
differed from compilers' understanding. In ~ 1975 ~ year Scheme \ cite {ss75} has shown,
that the interpreter and the compiler can be reconciled by placing both in a world where everything
lexical variables. { \ CommonLisp } scored the last nail in the ~ coffin of this
problems, deciding that the \ emph {good} understanding "is an understanding
compiler, and for it lexical variables are more convenient. The interpreter must
was to obey the new rules. The growing success of Scheme and other functional
languages ​​like ~ ML and the company, popularized the new approach first in ~ languages
programming, and then in the minds of people.


\ subsection {Far ~ and ~ short-range binding} %
\ label {basics / representing-functions / ssect: deep-or-shallow}

\ indexR {deep link}
\ indexR {link! far (deep)}
\ indexCS {lookup} {cost}
But it's not that easy. Language developers have found ways to speed up
search for values ​​of dynamic variables. If the environments are represented
associative lists, the time to search for the value of the variable (call cost
\ ic {lookup}) depends linearly on the length of the list. \ footnote * {Fortunately, statistics
shows that variables that are closer to the beginning of the list are used
more often those that are deep inside. By the way, it is worth noting that
lexical environments are on the average smaller in size than dynamic ones, since
The latter need to store all the variables involved in the ~ computations, including
of the same name \ cite {bak92a}.} This approach is called \ term {deep} or
\ term {deep binding}, since the values ​​of the dynamic
variables are usually located at some distance from the current local
environment.

\ indexR {shallow} binding}
\ indexR {close-up (shallow)}
\ indexE {Cval}
There is another method, called \ term {surface} or \ term {neighbor
(shallow binding). The essence of it is that the variable is directly related
with the place where its value is stored in the current moment, without reference to the environment.
The easiest way to do this is to put this value in a special character field,
corresponding to this variable; this field is called \ ic {Cval} or \ term {cell
values} (value cell). In this case, the cost of \ ic {lookup} is constant or about
Moreover: only one indirect addressing and, perhaps, a shift is required. As
Free cheese is only in the ~ mousetrap, it is worth noting that the function call
When using this method, it is more expensive, because it is required first
where "~ then store the old values ​​of the arguments, then write new values
in the fields of the corresponding symbols. And then, most importantly, after leaving
function, the old values ​​in ~ characters must be restored back, and this can
prevent optimization of tail recursion. (Although there are options: \ cite {sj93}.)

Changing the structure of the environment, we can partially emulate \ footnote {Here we are
we do not implement assignments to variables captured by closures. About this you can
read in ~ \ cite {bcsj86}.} short-range binding. But with a ~ caveat: list
arguments can not be ~ point (it will be easier to disassemble it) and we will not ~
check the arity of functions. The new functions will be denoted by the prefix \ ic {s.},
to not confuse them with others.

\ indexC {s.make-function}
\ indexC {s.lookup}
\ indexC {s.update "!}
\ begin {code: lisp}
(define (s.make-function variables body env)
  (lambda (values ​​current.env)
    (let ((old-bindings)
           (map (lambda (var val)
                  (let ((old-value (getprop var 'apval)))
                    (putprop var 'apval val)
                    (cons var old-value)))
                variables
                values)))
      (let ((result (eprogn body current.env)))
        (for-each (lambda (b) (putprop (car b) apval (cdr b)))
                  old-bindings)
        result))))

(define (s.lookup id env)
  (getprop id 'apval))

(define (s.update! id env value)
  (putprop id 'apval value))
\ end {code: lisp}

\ indexC {putprop} \ indexC {getprop}
In the ~ Scheme, the functions \ ic {putprop} and \ ic {getprop} are not included in the ~ standard, since here
do not like ineffective global side effects, but none the less, even
in ~ \ cite {as85} there are similar \ ic {put} and ~ \ ic {get}.
\ seeEx [lisp1-2-omega / ex: write-put / get-prop]

\ indexR {property lists}
\ indexR {characters! lists of properties}
\ indexE {P-list}
\ indexR {hash table}
Using these functions, we emulate the presence of the ~ character field, \ footnote * {This field
is named in honor of \ ic {apval} from ~ \ cite {mae + 62}. \ seePage [lisp1-2-omega / par: apval]
Then the field values ​​were actually stored in ~ naive P ~ ~ lists.} Where stored
value of the variable of the same name. Regardless of their current implementation, %
\ footnote * {These functions pass through the list of properties of the character (its P "~ list,
from ~ property) until they find the right one. The search speed, respectively,
linearly depends on the length of the list, unless ~ hash tables are used.}
consider that they are performed for a constant time.

Note that in this implementation, the definition environment
\ ic {env}. Therefore, to support closures, we need to change the implementation
\ ic {make-closure}, since it does not now have ~ access to the environment of the definition
(in view of his absence). When creating a closure, you need to view the body
functions, highlight all free variables and correctly store them inside
closure. We will implement this later.

\ indexE {rerooting}
Remote binding makes it easier to change environments and multitask, losing speed
search for variables. Near binding speeds up the search for variables, but loses
in the speed of calling functions. Henry ~ Baker \ cite {bak78} managed to combine the two
approach in a technique called \ term {rerooting}.

Finally, do not forget that the near and far link "--- these are only ways
implementation, they have no effect on the very concept of binding.


\ section {Global environment} \ label {basics / sect: global-environment}

\ indexR {library! functions}
\ indexR {Lisp primitives}
Empty global environment "--- this is sad, so most of the LISP systems
provide \ emph {library} functions. For example, in a ~ global environment
{ \ CommonLisp } (CLtL1) about 700 ~ functions, in ~ { \ LeLisp } there are more than ~ 1500,
y ~ { \ ZetaLisp } "--- more than ~ 10 \, 000. Without libraries, Lisp was only an applied
$ \ lambda $ "= calculus, in which you can not even print the results.
Libraries are very important for the end user. Special forms "--- this
building bricks for interpreter developers, but for the final
user of these bricks are the functions of libraries. By "apparently, it is
The absence in the pure Lisp of such banal things like the library
trigonometrical functions firmly entrenched the idea of ​​the unsuitability of Lisp for
<< serious programs >>. As stated in ~ \ cite {sla61}, the possibility of a character
integration or differentiation "--- this, of course, is wonderful, but to whom
need a language where there is not even a sinus or tangent?

We expect that all the familiar functions like \ ic {cons}, \ ic {car} { \ itp } will be
Available in a ~ global environment. You can also put a few simple
constants like logical values ​​and an empty list.

To do this, we define a pair of macros. Exclusively for convenience, because we
they have not even been talked about ~ yet. \ footnote * {Agree, it would be strange to squeeze
the whole book in the first chapter.} Macros "--- this is a fairly complex and important thing themselves
on their own, so that they are dedicated to their own chapter. \ seePage [chapter: macros]

These two macros will facilitate the filling of the global environment. The most global
The environment is an extension of the initial environment \ ic {env.init}.

\ ForLayout {display} { \ begingroup
\ lstset {aboveskip = \ smallskipamount , belowskip = \ smallskipamount }}

\ indexC {env.global}
\ indexC {definitial}
\ indexC {defprimitive}
\ begin {code: lisp}
(define env.global env.init)
| | \ ForLayout {display} { \ vskip -0.4 \ baselineskip } |
(define-syntax definitial
  (syntax-rules ()
    ((definitial name)
     (begin (set! env.global (cons (cons 'name' void) env.global))
            'name))
    ((definitial name value)
     (begin (set! env.global (cons (cons' name value) env.global))
            'name))))
| | \ ForLayout {display} { \ vskip -0.4 \ baselineskip } |
(define-syntax defprimitive
  (syntax-rules ()
    ((defprimitive name value arity)
     (definitial name
        (lambda (values)
          (if (= arity (length values))
              (apply value values); Native \ ic {apply} Scheme
              (wrong "Incorrect arity" (list 'name values) | \: |) | \: |) | \: |) | \: |) | \: |) | \: |) | \: |)
\ end {code: lisp}

\ indexC {the-false-value}
Despite the fact that the Scheme standard does not require this, we will define several
useful constants. Note that \ ic {t} "is a variable in the Lisp defined,
and \ ic { \ # # t} "is the value from the defining Lisp. It is suitable, since any
A value that does not coincide with ~ \ ic {the-false-value} is \ term {true}.

\ begin {code: lisp}
(definitial t #t)
(definitial f the-false-value)
(definitial nil '())
\ end {code: lisp}

\ ForLayout {display} { \ endgroup }

\ indexR {syntax! for \ protect \ ic { \ # t} and ~ \ ic { \ # f}}
\ indexR {Boolean values}
Although it is convenient "--- to have global variables with real objects for
data entities, but there is another solution: a special syntax. Scheme uses
\ ic { \ # t} and \ ic { \ # # f}, substituting for them logical \ term {truth} and
\ term {false}. In this there is a definite meaning:

\ begin {enumerate}
  \ item They are always visible: \ ic { \ # t} means \ term {truth} in any
        context, even when the local variable
        is called ~ \ ic {t}.

  \ item The value of \ ic { \ # t} can not be changed, but many interpreters
        will change the value of the global variable ~ \ ic {t}.
\ end {enumerate}

For example, the expression ~ \ ic {(if t 1 2)} returns ~ \ ic {2} if it is evaluated
in the following environment: \ ic {(let ((t \ # f)) (if t 1 2))}.

\ indexC {eq?}
There are many ways to enter such a syntax. The simplest way is "---
this is to insert the values ​​of \ ic {t} and ~ \ ic {f} into the calculator:

\ begin {code: lisp}
(define (evaluate e env)
  (if (atom? e)
      (cond ((eq? e 't) #t)
            ((eq? e 'f) #f)
            ...
            ((symbol? e) (lookup e env))
            ...
            (else (wrong "Can not evaluate" exp)))
      ...))
\ end {code: lisp}

\ indexR {inlining of functions}
\ indexR {embedding!} functions
\ indexR {functions! built-in}
\ indexR {bind! variable}
\ indexR {bind! unchanged}
We could also introduce the concepts of \ term {variable} and \ term {immutable}
binding. Immutable variables are rejected by assignment. Nothing and never
can not change the value of an immutable variable. Such a concept exists,
although not always ~ explicitly, in many systems. For example, there are so-called
\ term {inline functions} (also known as \ term {substitutions} or
\ term {recessed}), whose call can be completely replaced by direct substitution
their bodies. \ seePage [fast / fast / integrating / par: inlining]

In order to be able to substitute the function code instead of \ ic {(car ~ x)},
which returns the left element of the point pair ~ \ ic {x}, it is necessary to be absolutely
sure that the value of the global variable ~ \ ic {car} never changed
and will not change in the future. Look at what kind of trouble happens, if it is not ~ so:

\ begin {code: lisp}
(set! my-global (cons 'c' d))
   | | \ is | (d)
(set! my-test (lambda () (car my-global)))
   | | \ is | # <MY-TEST procedure>
(begin (set! car cdr)
       (set! my-global (cons 'a' b))
       (my-test))
   | | \ is | | | \ ii {?????} |
\ end {code: lisp}

Fortunately, only \ ic {a} or ~ \ ic {b} can result in the result . If
\ ic {my-test} uses the value ~ \ ic {car} at the time of determination, then we
we obtain ~ \ ic {a}. If ~ ic \ ic {my-test} will use the current
the value of ~ \ ic {car}, then the answer is ~ \ ic {b}. It will also be useful to compare this
aspect of \ ic {my-test} and \ ic {my-global}: usually the first version of the behavior is expected
from \ ic {my-test} when using the compiler, whereas for \ ic {my-global}
the second option is considered to be normal.
\ seePage [lisp1-2-omega / recusion / simple / code: redefine]

\ indexC {foo} \ indexC {bar} \ indexC {fib} \ indexC {fact}
Also we will add some working variables \ footnote {Unfortunately, now they
also initialized. This error will be fixed later.} In ~ global
environment, since now we have no way to dynamically create variables.
According to statistics, the proposed names are approximately {96,037 \, \% }
Used when testing newly written interpreters.

% \ ForLayout {display} {\ begingroup
% \ lstset {aboveskip = \ smallskipamount, belowskip = \ smallskipamount}}

\ begin {code: lisp}
(definitial foo)
(definitial bar)
(definitial fib)
(definitial fact)
\ end {code: lisp}

% \ ForLayout {display} {\ endgroup}

Finally, we define several primitive functions (not ~ all, because such
complete lists "--- this is a good sleeping pills.) The main difficulty is
in the combination of the mechanisms of calling the functions of the defined and defining languages.
Knowing that arguments are collected by our interpreter in a ~ list, it is quite simple
apply
to it \ ic {apply}. \ footnote * {You can only be happy for our choice not to call it
\ ic {invoke} << \ ic {apply} >>.} Note that the arity of the functions will be respected,
since we included the check in the ~ macro definition ~ \ ic {defprimitive}.

\ begin {code: lisp}
(defprimitive cons cons 2)
(defprimitive car car 1)
(defprimitive set-cdr! set-cdr! 2)
(defprimitive + + 2)
(defprimitive eq? eq? 2)
(defprimitive <<2)
\ end {code: lisp}


\ section {Run the interpreter} \ label {basics / sect: starting-the-interpreter}

We have only one thing left to show: the door to our new world.

\ indexC {chapter1-scheme}
\ begin {code: lisp}
(define (chapter1-scheme)
  (define (toplevel)
    (display (evaluate (read) env.global))
    (toplevel))
  (toplevel))
\ end {code: lisp}

Since our interpreter is still small and inexperienced, but gives great hopes,
we suggest that you write in an exercise as an option, allowing from it
go out.


\ section {Conclusion} \ label {basics / sect: conclusion}

\ indexR {language! and the meaning of programs}
Have we really determined the language now?

\ indexR {meaning of programs}
\ indexR {program! meaning}
There is no doubt that we can run \ ic {evaluate}, pass it on
expression, and it will soon return the result of the calculations. But the function itself
\ ic {evaluate} does not make any sense without the language of its definition, and if
we do not have a definition of the language of definition, then we can not do anything at all
to be sure. Since each lisper is a distant relative of the baron
Munchhausen, then, probably, it will suffice to take in the language of definition
the one we just defined. Consequently, we have the language ~ $ L $ ,
defined by the function ~ \ ic {evaluate}, written in the language ~ $ L $ . This language
is a solution of the following equation with respect to ~ $ L $ :
%
\ begin {equation *}
  \ forall \ pi  \ in  \ Vset {Programs} \ colon
    L \ text { \ ic {(evaluate (quote $ \ pi $ ) env.global)}} \ equiv L \ pi
\ end {equation *}

Execution of any program ~ $ \ pi $ written in ~ $ L $ (denoted as ~ $ L \ pi $ ),
should behave the same way (that ~ is to give the same result or never
not ~ complete), like the expression ~ \ ic {(evaluate (quote ~ $ \ pi $ ) env.global)} on
the same language ~ $ L $ . One of the interesting consequences of this statement is
that \ ic {evaluate} is capable of \ footnote {After we've opened all
used macros and abbreviations like \ ic {let}, \ ic {case}, \ ic {define}
{ \ itd } Then we'll need to put the function in the global environment
\ ic {evaluate}, \ ic {evlis} and ~ others} to interpret itself. Consequently,
the following expressions are equivalent:

\ begin {code: lisp}
(evaluate (quote | $ \ pi $ |) env.global) | \ eq |
  | | \ eq | (evaluate (quote (evaluate (quote | $ \ pi $ |) env.global)) env.global)
\ end {code: lisp}

Is there still a solution to the above equation? Yes, and there are a lot of them! Like us
seen before, the definition of \ ic {evaluate} does not necessarily indicate order
calculations. Many other properties of the language used to determine,
unconsciously \ emph {inherited} by the specified language. We, in fact, nothing
We can not say anything about them, but all these variants claim a solution to this
equations. Together with numerous trivial solutions. Consider,
for example, the language $ L_ {2001} $ , any program on which returns $ 2001 $ . Even
such a language satisfies this equation. Therefore, to determine the present
languages, other methods are needed, we will discuss them in the next chapters.


\ section {Exercises} \ label {basics / sect: exercises}

\ begin {exercise} \ label {basics / ex: tracer}
\ indexR {trace}
Modify the \ ic {evaluate} function so that it becomes a tracer. All
function calls must display actual arguments and return
result. It is easy to imagine the further development of this tool
in a step-by-step debugger, in addition, allowing you to change the order of execution
debugged program.
\ end {exercise}

\ begin {exercise} \ label {basics / ex: excess-recursion}
If the function ~ \ ic {evlis} is passed a list of one expression, it does
one extra recursive call. Think of a way to get rid of it.
\ end {exercise}

\ begin {exercise} \ label {basics / ex: new-extend}
Suppose the new function ~ \ ic {extend} is defined as follows:

\ indexC {extend}
\ begin {code: lisp}
(define (extend env names values)
  (cons (cons names values) env))
\ end {code: lisp}

Define the corresponding functions \ ic {lookup} and \ ic {update!}. Compare them
with ~ previously considered.
\ end {exercise}

\ begin {exercise} \ label {basics / ex: racks}
\ indexR {shallow} binding}
\ indexR {close-up (shallow)}
\ indexE {rack}
In ~ ~ cite {ss80}, another short-range coupling mechanism is proposed, called
\ term {rack}. The symbol is associated with a ~ field that does not store a single value, but
a stack of values. At each time point, the value of the variable is the
at the top of the stack value. Rewrite the functions \ ic {s.make-function},
\ ic {s.lookup} and ~ \ ic {s.update!} to implement this idea.
\ end {exercise}

\ begin {exercise} \ label {basics / ex: liar-liar!}
\ indexR {representation of boolean values}
If you have not noticed yet, the error in the definition of the function \ ic {<} has crept in! After all
This function must return the logical values ​​of the specified language, and
not defining. Correct this unfortunate misunderstanding.
\ end {exercise}

\ begin {exercise} \ label {basics / ex: def-list}
Define the function ~ \ ic {list}.
\ end {exercise}

\ begin {exercise} \ label {basics / ex: def-call / cc}
For adoring sequels: define \ ic {call / cc}.
\ end {exercise}

\ begin {exercise} \ label {basics / ex: def-apply}
Define the function \ ic {apply}.
\ end {exercise}

\ begin {exercise} \ label {basics / ex: def-end}
Define the function ~ \ ic {end}, which allows to exit the interpreter, developed
in this chapter.
\ end {exercise}

\ begin {exercise} \ label {basics / ex: slowpoke}
\ indexR {levels of interpretation}
\ indexR {interpretation! level}
Compare the speed of Scheme and \ ic {evaluate}. Then compare the speed of \ ic {evaluate}
and \ ic {evaluate}, interpreted using \ ic {evaluate}.
\ end {exercise}

\ begin {exercise} \ label {basics / ex: no-gensym}
Previously, we were able to successfully determine \ ic {begin} through \ ic {lambda}
\ seePage [basics / forms / sequence / par: gensym-puzzle], but for this we
It was necessary to use the function \ ic {gensym} to avoid collisions of names
variables. Override \ ic {begin} in the same spirit, but without using
\ ic {gensym}.
\ end {exercise}


\ section * {References}

All the works on interpreters, given in the beginning of this chapter, are
quite interesting, but if you can not ~ read so much, then here's the most
standing out of them:
\ begin {itemize}
  \ item among the << $ \ lambda $ "~ papers >>: ~ \ cite {ss78a};

  \ item is the shortest article in the world that contains the full interpreter
        Lisp: ~ \ cite {mcc78b};

  \ item << not strictly formal >> description of interpretation: ~ \ cite {rey72};

  \ item The local book of Genesis: ~ \ cite {mae + 62}.
\ end {itemize}
