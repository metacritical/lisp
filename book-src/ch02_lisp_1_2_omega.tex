% - * - coding: utf-8 - * -
\ chapter { \ texorpdfstring {Lisp, 1, 2, \ dots , $ \ omega $ } {Lisp, 1, 2, ..., ω}} %
\ label {chapter: lisp1-2-omega}

\ initial {0.0ex} {0.0ex} {F} { \ kern 0.45ex Functions take a central place
in Lisp, so it is obvious that the effectiveness of their calls is very important.
Not surprisingly, over the past time, the relevant mechanisms have been studied
along and across, and studies on the diagonal are still going on. In this chapter
it will be about various options for understanding functions and their challenges. We will talk
about what is called \ Lisp 1 and \ Lisp 2, as well as their differences caused by
concept of individual namespaces. The chapter ends with a review
recursion and ways to implement it, taking into account the issues studied.

\ bigskip

Among the various objects used by the interpreter, functions require
special approach. This basic object type has a personal constructor:
\ ic {lambda}, and supports at least one operation: application of the function
to arguments. Hardly it is possible to describe it even easier, without making it completely useless.
By the way, the fact that the ~ functions have a few characteristic features make them perfect
building block, encapsulating behavior; function can do only what
for which it is programmed. For example, with the help of functions one can represent
objects that have fields and methods \ cite {ar88}. In ~ Scheme functions are represented
in general, everything that can only be represented in the form of a function.

\ phantomlabel {lisp1-2-omega / par: apval}
\ indexC {APVAL} \ indexC {EXPR} \ indexC {MACRO}
Attempts to make function calls more efficient resulted in a ~ set (often
incompatible) language variations. Initially, \ LISP ~ 1.5 \ cite {mae + 62} did not have
concept of object-function. The implementation was such that the variable, function, and
the macro could simultaneously carry the same name, as they were stored in ~ different
cells ( \ ic {APVAL}, \ ic {EXPR} and \ ic {MACRO} \ footnote { \ ic {APVAL},
\ term {A Permanent VALue}, for global variables; \ ic {EXPR},
\ term {EXPRession}, for global functions; \ ic {MACRO} for macros.}) list
properties of the corresponding symbol.

\ indexCS {lambda} {as a keyword}
Maclisp allocated named functions to a ~ separate category, and its child
{ \ CommonLisp } (CLtL2) ~ \ cite {ste90} only recently received support for functions as
objects of the first class. In ~ { \ CommonLisp } \ ic {lambda} "is the keyword
with ~ value: << Warning! Next is the definition of anonymous function >>.
\ ic {lambda} -forms do not have a return value and can only be
in ~ certain places: as the first element of the call form or as the first argument
special form ~ \ ic {function}.

\ indexR {first class objects}
\ indexR {objects, full}
\ indexR {first class (objects)}
\ indexR {first class (objects) | see {high-grade objects}}
\ indexR {high-grade objects}
In contrast to them, Scheme from the very first version of the 1975 ~ year had functional
objects and a single namespace, extending the concept of \ term {first class}
almost everything. Objects of the first class (full objects) can
to be accepted or returned by functions, to be in the ~ list, array, variable
{ \ itd } This approach is widely used in ~ a class of languages ​​like ~ ML, it will be the same
used here.


\ section { \ texorpdfstring { \ protect \ Lisp 1} {Lisp₁}} \ label {lisp1-2-omega / sect: lisp1}

\ indexE {Lisp1 @ \ protect \ Lisp 1}
\ indexR {Lisp! Lisp1 @ \ protect \ Lisp 1}
In the previous chapter, we used this approach: functions were objects
(they were created by \ ic {make-function}); in the process of computation we did not distinguish
functions and arguments, when calculating the form of application there was no difference
between calculating the element in place of \ term {function} and calculating the elements,
located in place \ term {parameters}. Let's look again at
interpreter from the previous chapter:

\ begin {code: lisp}
(define (evaluate e env)
  (if (atom? e) ...
      (case (car e)
        ...
        ((lambda) (make-function (cadr e) (cddr e) env))
        (else (invoke (evaluate (car e) env)
                      (evlis (cdr e) env))))))
\ end {code: lisp}

The most important thing in it is:

\ begin {enumerate}
  \ item  \ ic {lambda} creates full objects "--- closures," ---
        which preserve the environment of its definition.

  \ item When the function is used, everything is evaluated in the same way:
        with the help of \ ic {evaluate}; \ ic {evlis} just calls
        \ ic {evaluate} for all items in the list.
\ end {enumerate}

Thanks to these two qualities, Scheme is the representative of the ~ \ Lisp 1 family .


\ section { \ texorpdfstring { \ protect \ Lisp 2} {Lisp₂}} \ label {lisp1-2-omega / sect: lisp2}

\ indexE {Lisp2 @ \ protect \ Lisp 2}
\ indexR {Lisp! Lisp2 @ \ protect \ Lisp 2}
In most programs on Lisp, when the function calls the first form element
is the name of the global function. This is also true for programs from the previous
chapter. We could make this restriction part of the language. It would not be ~ strong
changed the appearance of the code, but it would be easier to calculate the forms: for the first element
no longer need all the power \ ic {evaluate}, enough mini-calculator that ~ would
I could only search for the desired function by name. To implement this idea, we will change
the corresponding part of \ ic {evaluate}:

\ begin {code: lisp}
...
(else (invoke (lookup (car e) env)
              (evlis (cdr e) env))) ...
\ end {code: lisp}

\ indexC {fenv}
\ indexR {environment! functional}
Now we have two different calculators, one for each case where we can
meet a variable: in place of the function or at the place of the argument. We can
differently handle the same identifier in ~ depending on its
position. If the functions require a special approach, then logical
allocate a special namespace for them. Obviously, it's easier to search for names
functions in an environment where there are no names of variables that only interfere.
The interpreter is easy to adapt for this case. We need an environment
for functions \ ic {fenv} and a specialized calculator
\ ic {evaluate-application}, which knows how to handle the ~ elements of the given
environment. Since now we have two environments and two calculators, we will name
this is \ Lisp 2 ~ \ cite {sg93}.

\ indexC {f.evaluate}
\ begin {code: lisp}
(define (f.evaluate e env fenv)
  (if (atom? e)
      (cond ((symbol? e) (lookup e env))
            ((or (number? e) (string? e) (char? e)
                 (boolean? e) (vector? e))
             (e)
            (else (wrong "Can not evaluate"))))
      (case (car e)
        ((quote) (cadr e))
        ((if) (if (f.evaluate (cadr e) env fenv)
                      (f.evaluate (caddr e) env fenv)
                      (f.evaluate (cadddr e) env fenv)))
        ((begin) (f.eprogn (cdr e) env fenv))
        ((set!) (update! (cadr e)
                           env
                           (f.evaluate (caddr e) env fenv)))
        ((lambda) (f.make-function (cadr e) (cddr e) env fenv))
        (else (evaluate-application (car e)
                                        (f.evlis (cdr e) env fenv)
                                        env
                                        fenv)))))
\ end {code: lisp}

The calculation of the forms is answered by the \ ic {evaluate-application}, which takes
<< raw >> function name, calculated argument values ​​and two current environments.
As you can see from the definition of \ ic {lambda}, when the function is created, both
environment: \ ic {env} and \ ic {fenv}. In the rest the new version differs only in that,
that for \ ic {env} follows (like ~ shadow) \ ic {fenv}. Naturally, it is still necessary
modify the functions \ ic {evlis} and \ ic {eprogn} so that they use \ ic {fenv}:

\ indexC {f.evlis}
\ indexC {f.eprogn}
\ begin {code: lisp}
(define (f.evlis exps env fenv)
  (if (pair? exps)
      (cons (f.evaluate (car exps) env fenv)
            (f.evlis (cdr exps) env fenv))
      '()))

(define (f.eprogn exps env fenv)
  (if (pair? exps)
    (if (pair? (cdr exps))
        (begin (f.evaluate (car exps) env fenv)
               (f.eprogn (cdr exps) env fenv))
        (f.evaluate (car exps) env fenv))
    empty-begin))
\ end {code: lisp}

When a function is called, its arguments expand the environment of the variables, for this
Only the way to create a function needs to be modified; call mechanism
( \ ic {invoke}) does not require changes.

\ indexC {f.make-function}
\ begin {code: lisp}
(define (f.make-function variables body env fenv)
  (lambda (values)
    (f.eprogn body (extend env variables values) fenv)))
\ end {code: lisp}

The task \ ic {evaluate-application} is to analyze the functional
The form element and ensure the correct call. If we follow the path
{ \ CommonLisp }, then the place of the functional element can be either a symbol,
or \ ic {lambda} -form.

\ indexC {evaluate-application}
\ begin {code: lisp} [label = lisp1-2-omega / lisp2 / src: erroneous-eval-application]
(define (evaluate-application fn args env fenv)
  (cond ((symbol? fn)
         (invoke (lookup fn fenv) args))
        ((and (pair? fn) (eq? (car fn) 'lambda))
         (f.eprogn (cddr fn)
                   (extend env (cadr fn) args)
                   fenv))
        (else (wrong "Incorrect functional term" fn))))
\ end {code: lisp}

And what did we finally get, and what did we lose? The first obvious advantage
It consists in the fact that to search for a function by name only a simple call is needed
\ ic {lookup}, not ~ \ ic {f.evaluate} with subsequent long parsing.
Further, since we got rid of all references to variables in ~ \ ic {fenv}, this
the environment has become more compact, and hence the search for it has accelerated. The second
the advantage is to accelerate the computation of forms, where the function is located at the location of the function
\ ic {lambda} -form. For example:

\ begin {code: lisp}
(let ((state-tax 1.186))
  ((lambda (x) (* state-tax x)) (read)))
\ end {code: lisp}

In this case, for \ ic {(lambda (x) (* ~ state-tax ~ x))} no ~ will be created
closure, her body will be calculated right away in the right environment.

The problem is that these two advantages do not really give anything, because they are the same
results can be achieved in ~ \ Lisp 1 with a small preliminary
analysis. There is only one really pleasant moment: \ Lisp 2 slightly
faster, since we can be sure that any name in ~ \ ic {fenv} is associated
with a function and with nothing else, which means checking for what is really
function, it is necessary to execute only once: at function placing in ~ an environment. And ~ so
How each name should be associated with a ~ function, then all unused names can be
just associate it with ~ \ ic {wrong}.

In view of the fact that each name in ~ \ ic {fenv} is associated with a ~ function, we can generally
get rid of the call \ ic {invoke}, and at the same time from calling \ ic {procedure?} inside.
This is possible, because we implement the interpreter on Scheme (in ~ { CommonLisp }
forms like \ ic {((lookup fn fenv) args)} are forbidden). For this, a little
change start \ ic {evaluate-application}:

\ begin {code: lisp}
(define (evaluate-application fn args env fenv)
  (cond ((symbol? fn) ((lookup fn fenv) args))
        ...))
\ end {code: lisp}

In Lisp, functions are called so often that any time gain on calls "---
this is already good and can greatly affect performance. But this particular
the payoff is not so great: it only appears for dynamically determined
functions, whereas in most cases the called function is known statically.

Now let's talk about what we've lost. And ~ we lost the opportunity
\ emph {compute} the function to be used. We consider the expression \ ic {( ψ \ ii {condition}
(+ 3 ~ 4) (* 3 ~ 4))}. In ~ Scheme, you can easily render the arguments \ ic {3} and ~ \ ic {4} for
brackets: \ ic {({if \ ii {condition} + *) 3 ~ 4)}. It's simple, clear and logical.
In fact, this is an identity. But in ~ \ Lisp 2, this program will cause an error, because
\ ic {if} is the form standing in place of the function, "is not a ~ character,
nor the ~ \ ic {lambda} -form.


\ subsection {Compute the functions} \ label {lisp1-2-omega / lisp2 / ssect: eval-func-term}

The capabilities of the current environment of functions are still far from the possibilities of the environment
variables (the environment of the parameters). In particular, as you have seen, we can not
calculate the function to be used. A traditional trick that has existed since the time
Maclisp, is that if \ ic {evaluate-application} encounters
that "something incomprehensible, then it passes it to the function \ ic {f.evaluate}:

\ indexC {evaluate-application}
\ begin {code: lisp}
(define (evaluate-application2 fn args env fenv)
  (cond ((symbol? fn)
         ((lookup fn fenv) args))
        ((and (pair? fn) (eq? (car fn) 'lambda))
         (f.eprogn (cddr fn)
                   (extend env (cadr fn) args)
                   fenv))
        [(else (evaluate-application2]
               [(f.evaluate fn env fenv) args env fenv))]))
\ end {code: lisp}

Now our problem is solved as follows:

\ begin {code: lisp}
(if | | ii | the condition} | (+ 3 4) (* 3 4)) | \ eq | ((| | | ii (the condition} | '+' *) 3 4)
\ end {code: lisp}

Not ~ very elegant, as it is necessary to write extra quotes, but at least
it works. Works, but, perhaps, too diligently; sometimes so that
falls into an infinite loop.

\ begin {code: lisp}
('' '' '' '' '' '' '1789 | \ ii {arguments} |)
\ end {code: lisp}

The expression \ ic {'{}' {} '{}' {} '{}' {} '{}' {} '{}' {} '{}' {} '1789}
is calculated thirteen times in a row, while \ ic {evaluate-application2} does not reach ~
number ~ 1789, and then it gets into an infinite loop, since 1789 "is this
not a function and not a character, which means that it must be passed to ~ \ ic {f.evaluate},
to get \ textdots \ again the number ~ 1789! In short ~ speaking, it is necessary more carefully
keep track of what is being transferred \ ic {f.evaluate}. The problem remains even then,
when we rewrite the interpreter as follows:

\ begin {code: lisp}
(define (evaluate-application3 fn args env fenv)
  (cond
    ((symbol? fn)
     (let ((fun (lookup fn fenv)))
       (if fun (fun args)
           (evaluate-application3 (lookup fn env) args env fenv))))
    ...))
\ end {code: lisp}

In this case, if the symbol is missing in the ~ functional environment, then the search
is repeated already in the environment of the variables. Oh! Even if we assume that
there is no function \ ic {foo}, we can calmly fixate ourselves in calculating
the value of the variable. For example:

\ begin {code: lisp}
(let ((foo 'foo))
  (foo | \ ii {arguments} |))
\ end {code: lisp}

No, you can, of course, embed a ~ \ ic {evaluate-application} protection from this,
checking whether the value of the variable is the same as its name. But you can write
and ~ so:

\ begin {code: lisp}
(let ((flip 'flop)
      (flop 'flip))
  (flip))
\ end {code: lisp}

The only option that so far not ~ managed to be fooled "--- this is the very first on
page ~ \ pageref {lisp1-2-omega / lisp2 / src: erroneous-eval-application}, so
it is necessary to find another method for calculating the functional element of the form.


\ subsection {Duality of worlds} \ label {lisp1-2-omega / lisp2 / ssect: duality}

Summarizing these difficulties, we can say that there are some calculations,
the parameters belonging to the world that we want to transfer to the world of functions,
and vice versa. More precisely, we want to be able to return a function as
result of calculations and transfer it as an argument of calculations.

\ indexC {funcall}
If it is absolutely necessary that the name of the function should be in place of the function, but in the same way
time we want to be able to calculate the necessary function, it will be
a sufficiently predefined function that knows how to apply functions
to arguments. Call it \ ic {funcall} (from ~ \ term {function call}). It applies
its first argument (which must be a function) to the others. With its help
our problem is solved as follows:

\ begin {code: lisp}
(if | | ii | the condition} | (+ 3 4) (* 3 4)) | \ eq | (funcall (if | \ ii {condition} | + *) 3 4)
\ end {code: lisp}

All arguments (the first in the number) are calculated by the usual \ ic {f.evaluate}.
The function \ ic {funcall} only takes everything ready and executes the call. We can easily
define \ ic {funcall} as

\ indexC {funcall}
\ begin {code: lisp}
(define (funcall.args)
  (if (> (length args) 1)
      (invoke (car args) (cdr args))
      (wrong "Incorrect arity" 'funcall)))
\ end {code: lisp}

In ~ \ Lisp 2 \ ic {funcall} is used for dynamic calculation of functions. In all
The remaining cases of the function are known and not ~ required to verify, really ~ li
this is a function.

Notice the call to \ ic {invoke} in ~ \ ic {funcall}. This function checks,
is its argument really a function, in contrast to
\ ic {evaluate-application}, where this check is not performed. The functions \ ic {funcall}
is more similar to \ ic {apply}: both accept the first argument as a function, and after it
"--- necessary arguments, the only difference between them is that \ ic {funcall}
statically knows the number of arguments passed.

\ indexE {+ @ \ ic {+} (in ~ \ protect \ CommonLisp )}
\ indexE {* @ \ ic {*} (in ~ \ protect \ CommonLisp )}
\ indexE {REPL! definition}
\ indexR {interactive session (REPL)}
Unfortunately, there is one more small problem. When we write \ ic {(if
\ ii {condition} + ~ *)}, we expect to get the addition or multiplication function. But that,
what we are now getting is "--- this is the value of the variable \ ic {+} or ~ \ ic {*}!
In ~ { \ CommonLisp }, the values ​​of these variables are not closely related to ~ arithmetic: they
store the last read and last returned REPL \ trnote * {REPL "---
<< \ term {read - eval - print loop} >>, an interactive session. In the interpreter from
The previous chapter corresponds to the function \ ic {toplevel}.} value!

\ indexC {function}
We introduced \ ic {funcall} in order to be able to perform calculations
with functions as co-values. Of course, in the interpreter there is also
the reverse process: after all \ ic {evaluate-application} gets exactly such values
and calls them as functions; but these transformations occur implicitly.
In the presence of \ ic {funcall}, we need to be able to explicitly turn the name
function variable ~ \ ic {+} to the corresponding function from the environment of functions.
To do this, we'll introduce one more device: \ ic {function}. This special
form takes the name of the function and returns the corresponding function
value. Now we can freely move between two worlds:

\ begin {code: lisp}
(if | | ii | the condition} | (+ 3 4) (* 3 4)) | \ equals |
       | | \ equals | (funcall (if | \ ii {condition} | (function +) (function *)) 3 4)
\ end {code: lisp}

To define \ ic {function}, it's enough to add the appropriate processing
in ~ \ ic {f.evaluate}. This form ~ \ ic {function} does not have anything to do with ~ the same name
\ seePage [basics / repr-func / dyn-and-lex-bind / src: closure-eval] form
\ ic {(function (lambda \ ii {variables} \ ii {body}))} that creates closures. Here
we define \ ic {(function \ ii {name-function})}, which converts the names of functions
in their values.

\ begin {code: lisp}
...
((function)
 (cond ((symbol? (cadr e))
        (lookup (cadr e) fenv))
       (else (wrong "Incorrect function" (cadr e))))) ...
\ end {code: lisp}

\ indexCS {lambda} {as a label}
We can easily expand this definition so that it accepts and
\ ic {lambda} -form, as it is done in ~ { \ CommonLisp } or at us on
page ~ \ pageref {basics / repr-func / dyn-and-lex-bind / src: closure-eval}. But in this
there is not much point, because our \ ic {lambda} immediately returns the desired value.
In ~ { \ CommonLisp } such an extension is necessary, because there \ ic {lambda} only
marks the function code and "special form" \ ic {lambda} is allowed or
be in place of a function, or be the first argument of a special form
\ ic {function}.

The function \ ic {funcall} allows you to place the result of calculations from the world of parameters
in a variable from the world of functions. And ~ on the contrary, \ ic {function} allows you to place
value from the world of functions to a variable from the world of parameters. They see
obvious parallels: << application functions "--- \ ic {funcall} >> and << dereferencing
variables "--- \ ic {function} >>. Simultaneous existence of two worlds and
the possibility of communication between them requires such bridges.

\ indexR {inlining of functions}
\ indexR {functions! built-in}
\ indexR {embedding!} functions
Note that now we do not have the ability to change the functional environment;
we do not have an appropriate assignment. This allows compilers to be safe
and in full force to use the mechanism \ term {inline functions}. One of
attractive aspects of using multiple namespaces is
the opportunity to give each of them special properties.


\ subsection { \ texorpdfstring {Use \ protect \ Lisp 2} {Use Lisp₂}} %
\ label {lisp1-2-omega / lisp2 / ssect: using}

To fully define our \ Lisp 2, it remains to specify the initial functional
environment and run the interpreter in the loop itself, \ ic {f.evaluate}. Definition
global functional environment is not much different from the environment
variables: you just need to expand another initial environment.

\ indexC {fenv.global}
\ indexC {definitial-function}
\ indexC {defprimitive}
\ begin {code: lisp}
(define fenv.global '())

(define-syntax definitial-function
  (syntax-rules ()
    ((definitial-function name)
     (begin (set! fenv.global (cons (cons 'name' void) fenv.global))
            'name))
    ((definitial-function name value)
     (begin (set! fenv.global (cons (cons' name value) fenv.global))
            'name))))

(define-syntax defprimitive
  (syntax-rules ()
    ((defprimitive name value arity)
     (definitial-function name
       (lambda (values)
         (if (= arity (length values))
             (apply value values)
             (wrong "Incorrect arity"
              (list 'name' values))))))))

(defprimitive car car 1)
(defprimitive cons cons 2)
\ end {code: lisp}

\ noindent
Finally:

\ begin {code: lisp}
(define (| \ fbox { \ ii {undeniably \ Lisp 2}} |)
  (define (toplevel)
    (display (f.evaluate (read) env.global fenv.global))
    (toplevel))
  (toplevel))
\ end {code: lisp}


\ subsection {Extend functional environment} %
\ label {lisp1-2-omega / lisp2 / ssect: enriching}

\ indexR {environment! as data type}
All environments "are objects of some abstract data type.
are we expecting from this type of data? We expect that he will keep the links between
names and essences, that we can by name find the necessary entity, and that we
we can add new links. We also want to be able to determine local
function, and this requires a mechanism for local expansion of the functional
environment. In general, I want \ ic {let}, but only for functions. Now
functional environment is unchangeable, so it would be nice to have such a
opportunity. Create a new special form \ ic {flet} ( \ term {functional let})
with the following syntax:

\ indexC {flet}
\ begin {code: lisp}
(flet ((| \ ii {name \ sub 1} | | \ ii {arguments \ sub 1} | | \ ii {body \ sub 1} |)
        ...
       (| \ ii {name \ sub {n}} | | \ ii {arguments \ sub {n}} | | \ ii {body \ sub {n}} |))
  | | \ ii {expressions} | ...)
\ end {code: lisp}

Since \ ic {flet} can only create local functions, there is no need
write \ ic {lambda}, this is implied. Special form \ ic {flet}
computes the forms \ ic {(lambda \ ii {arguments \ sub {i}} \ ii {body \ sub {i}}} and associates
the resulting values ​​with the names ~ \ ii {name \ sub {i}} in the functional environment. After
This \ ii {expression} is evaluated in the extended environment where you can place
\ ii {name \ sub {i}} in place of the function or pass it to ~ \ ic {function}, if
an appropriate \ nohyp {closure} is needed .

Add \ ic {} flet in ~ \ ic {} f.evaluate simple:

\ begin {code: lisp}
...
((flet)
 (f.eprogn
  (cddr e)
  env
  (extend fenv
          (map car (cadr e))
          (map (lambda (def)
                 (f.make-function (cadr def) (cddr def) env fenv))
               (cadr e))))) ...
\ end {code: lisp}

The form \ ic {flet} seriously extends our capabilities: for example, it allows
\ ic {lambda} close in itself not only \ ic {env}, but also ~ \ ic {fenv}. Consider
example:

\ begin {code: lisp}
(flet ((square (x) (* xx))
  (lambda (x) (square (square x))))
\ end {code: lisp}

The value of this expression is an anonymous function that constructs a number
in the fourth degree. This closure preserves itself and uses the local
function ~ \ ic {square}.


\ section {Other features} \ label {lisp1-2-omega / sect: extensions}

As soon as we made the calculator behave in a special way to the functions, to the mind
At the same time other options for using this feature come up. For example, we
could interpret numbers as functions of accessors for lists:

\ begin {code: lisp}
(2 '(foo bar hux wok)) | \ is | hux
(-2 '(foo bar hux wok)) | \ is | (hux wok)
\ end {code: lisp}

The number ~ $ n $ is considered a synonym for ~ \ ic {cad \ sup { $ n $ } r} if it is nonnegative,
or \ ic {cd \ sup { $ -n $ } r} if it is less than zero. Basic accessors \ ic {car} and
\ ic {cdr} there correspond the numbers \ ic {0} and ~ \ ic {-1}. After that, elementary
the purely algebraic transformations $ \ text { \ ic {(-1 ~ (-2 ~ $ \ pi $ ))}}
\ eq  \ text { \ ic {(-3 ~ $ \ pi $ )}} $ or $ \ text { \ ic {(2 ~ (-3 ~ $ \ pi $ ))}} \ eq
\ text { \ ic {(5 ~ $ \ pi $ )}} $ .

You can also give meaning to the function lists in place of the function:

\ begin {code: lisp}
((list + - *) 5 3) | \ is | (8 2 15)
\ end {code: lisp}

The use of the list of functions returns a list of the results of each application
element-function to the corresponding argument. In fact, the previous example
"--- this is a short entry for

\ begin {code: lisp}
(map (lambda (f) (f 5 3))
     (list + - *))
\ end {code: lisp}

Finally, we could resolve the functions to be the second element of the application,
emulating the usual infix record: the expression ~ \ ic {(1 + 2)} returns ~ \ ic {3}.
For example, this behavior is implemented in ~ DWIM from ~ \ cite {tei74, tei76}.

But, firstly, such innovations are dangerous, as they reduce the amount of
erroneous forms, and therefore make it difficult to find errors that would otherwise be easy
were. Secondly, they do not give any significant savings either at the end
ends are rarely used. In the third place, they even more strongly share the functions and
Functional objects that can be used as functions. Lists or numbers
become callable, but not at all ~ commit to be functions. In the end, they become
possible outrages like

\ begin {code: lisp}
(apply (list 2 (list 0 (+ 1 2)))
       '(foo bar hux wok))
   | | \ is | (hux (foo wok))
\ end {code: lisp}

Therefore, it is not recommended to implement these innovations as part of the basic
language. \ seeEx [lisp1-2-omega / ex: innovations]


\ section { \ texorpdfstring {Comparison \ protect \ Lisp 1 ~ and ~ \ protect \ Lisp 2} %
{Comparison of Lisp₁ and Lisp₂}} %
\ label {lisp1-2-omega / sect: comparison}

Approaching the end of our research \ Lisp 1 and ~ \ Lisp 2, what can we say
in the end about these two approaches?

\ indexR {namespaces}
\ indexE {Lispn \ \ protect \ Lisp { \ protect \ ii {n}}}
\ indexR {Lisp! Lispn @ \ protect \ Lisp { \ protect \ ii {n}}}
Scheme is \ Lisp 1, it's nice to program and it's easy to train, so
How the calculation process is simple and consistent. \ Lisp 2 ~ the same is more complicated, because
that the existence of two worlds requires the use of special forms for the transition
between them. { \ CommonLisp } is not ~ absolutely \ Lisp 2, since it has many
other namespaces: for labels of lexical transitions, for labels of forms
\ ic {tagbody} { \ itd } Therefore sometimes it is called ~ \ Lisp { \ ii {n}}, since one and
then the same name can behave in various ways depending on the syntactic
role. Languages ​​with strong syntax (or, as they say, with despotic syntax)
often have many namespaces or many environments (for variables,
for functions, for types { \ itd }). Each of these environments has its own
features. For example, if the functional environment is unchangeable (then ~ is
functions can not be assigned new values), then it becomes very easy
optimize calls to local functions.

In programs on \ Lisp 2 functions are clearly separated from the rest of the calculations. This is very
advantageous distinction, so, according to \ cite {sen89}, it should be applied
all good Scheme compilers. Within them, programs are translated into
\ Lisp A 2-language that can be better compiled. The compiler clearly defines
each place where you want to insert \ ic {funcall}, "--- those places where functions
are calculated dynamically. Users \ Lisp 2 are forced to do part of the job
compiler by hand, so in the end they better understand the cost of using
their designs.

\ indexE {Lisp2 @ \ protect \ Lisp 2}
\ indexR {Lisp! Lisp2 @ \ protect \ Lisp 2}
On the previous pages, we have analyzed quite a few variations, so now
it will be useful to collect everything together and give one more definition "--- the simplest
from a possible "--- another \ Lisp 2-language similar to { \ CommonLisp }. This time
we confine ourselves to introducing the function \ ic {f.lookup}, which searches for the function by
name in a ~ functional environment, and if not ~ finds, then calls \ ic {wrong}. it
will guarantee the final execution time of \ ic {f.lookup}. Of course,
the consequence of such a campaign will be the appearance of peculiar errors of the slowed down
action, since in itself an invocation of an undefined function is not considered
erroneous. Problems arise only when you try to call, which can occur
much later, if not at all.

\ indexC {f.evaluate}
\ indexC {f.evaluate-application}
\ indexC {f.lookup}
\ begin {code: lisp}
(define (f.evaluate e env fenv)
  (if (atom? e)
      (cond ((symbol? e) (lookup e env))
            ((or (number? e) (string? e) (char? e)
                 (boolean? e) (vector? e))
             (e)
            (else (wrong "Can not evaluate"))))
      (case (car e)
        ((quote) (cadr e))
        ((if) (if (f.evaluate (cadr e) env fenv)
                      (f.evaluate (caddr e) env fenv)
                      (f.evaluate (cadddr e) env fenv)))
        ((begin) (f.eprogn (cdr e) env fenv))
        ((set!) (update! (cadr e)
                           env
                           (f.evaluate (caddr e) env fenv)))
        ((lambda) (f.make-function (cadr e) (cddr e) env fenv))
        ((function)
         (cond ((symbol? (cadr e))
                (f.lookup (cadr e) fenv))
               ((and (pair? (cadr e)) (eq? (car (cadr e)) 'lambda))
                (f.make-function
                 (cadr (cadr e)) (cddr (cadr e)) env fenv))
               (else (wrong "Incorrect function" (cadr e)))))
        ((flet)
         (f.progn (cddr e)
                  env
                  (extend fenv (map car (cadr e))
                          (map (lambda (def)
                                 (f.make-function (cadr def)
                                                  (cddr def)
                                                  env fenv))
                               (cadr e)))))
        ((labels)
         (let ((new-fenv (extend fenv
                                 (map car (cadr e))
                                 (map (lambda (def) 'void)
                                      (cadr e)))))
           (for-each (lambda (def)
                       (update! (car def)
                                new-fenv
                                (f.make-function (cadr def) (cddr def)
                                                 env new-fenv)))
                     (cadr e))
           (f.eprogn (cddr e) env new-fenv)))
        (else (f.evaluate-application (car e)
                                      (f.evlis (cdr e) env fenv)
                                      env
                                      fenv)))))

(define (f.evaluate-application fn args env fenv)
  (cond ((symbol? fn)
         ((f.lookup fn fenv) args))
        ((and (pair? fn) (eq? (car fn) 'lambda))
         (f.eprogn (cddr fn)
                   (extend env (cadr fn) args)
                   fenv))
        (else (wrong "Incorrect functional term" fn))))

(define (f.lookup id fenv)
  (if (pair? fenv)
      (if (eq? (caar fenv) id)
          (cdar fenv)
          (f.lookup id (cdr fenv)))
      (lambda (values)
        (wrong "No such functional binding" id))))
\ end {code: lisp}

Another important, in the opinion of \ cite {gp88}, is the practical difference between \ Lisp 1 and
\ Lisp 2 consists in ~ readability. Although, of course, experienced programmers are unlikely
will write that "~ something like:

\ begin {code: lisp}
(defun foo (list)
  (list list))
\ end {code: lisp}

\ indexR {self-application! in ~ \ protect \ Lisp 1 and ~ \ protect \ Lisp 2}
\ noindent
From the point of view of \ Lisp 1, \ ic {(list ~ list)} "--- this is quite ~ admissible
self-application, \ footnote * {There are other self-applications that have
meaning, although there are not much of them. For example, \ ic {(number? ~ Number?)}.} But in ~ \ Lisp 2
this expression has a completely different meaning. In ~ { \ CommonLisp } these two names
belong to different environments and do not conflict. Nevertheless, it is better to avoid
similar naming style and not ~ call local variables by the names of known
global functions; this will help to avoid problems with ~ macros and make programs
less dependent on the dialect used.

\ indexR {macros! in ~ \ protect \ Lisp 1 and ~ \ protect \ Lisp 2}
The next difference between \ Lisp 1 and \ Lisp 2 is in the proper macros.
In ~ { \ CommonLisp } it is rather difficult to write a macro that opens
in a ~ \ ic {lambda} -form that would be useful, for example, when implementing an object
system. The point is that { \ CommonLisp } limits the places where it can appear
\ ic {lambda}. It can only stand in place of the function, so the construction
\ ic {(... (lambda ~ ...) ...)} will cause an error in ~ { \ CommonLisp }. The only thing
exception "--- \ ic {lambda} can be the first argument of \ ic {function}. But itself
\ ic {function} can only be a function parameter, so \ ic {((function
(lambda ~ ...)) ...)} "is again an error.If the macro does not know where it is
will open as an argument or as a function, it can not be used without
some complication of programs. For the same system of objects, for example,
open the macro in ~ \ ic {(function (lambda ~ ...))}, and then manually wrap it
it's in ~ \ ic {funcall} where it is called as a function.

\ indexR {name conflict}
\ indexR {scope! name conflict}
Finally, it is worth mentioning the radical solution used by many languages.
You can prohibit the use of the same name, even in ~ different
environments. The previous example with ~ \ ic {list} would cause an error, since
the name ~ \ ic {list} is already used in the ~ functional environment. Almost all
The Lisp and Scheme implementations forbid the variable from having the same name as the function
or a macro. This rule really makes life easier.


\ section {Namespaces} \ label {lisp1-2-omega / sect: namespaces}

\ indexR {namespaces}
\ term {Environment} establishes a match between names and objects. For this
moment we know two types of environments: the usual environment \ ic {env} and
functional \ ic {fenv}. The reason they are divided is the desire
accelerate function calls and separate functions from variables. But this division
required us to enter two different calculators, as well as a transfer mechanism
the essences of one environment in another, "--- and this made the language more complicated.
dynamic variables, we mentioned that modern Lisp dialects (like
ILOG ~ Talk, { \ EuLisp }, { \ ISLisp }) put the dynamic variables into a separate
namespace. Now we will consider this decision in more detail. Pursuing this,
we illustrate the very idea of \ term {namespaces}.

\ bigskip

\ indexR {bindings}
\ indexR {bindings | seealso {link}}
\ indexR {bindings} capture}
\ indexR {second-class objects}
Environments can be understood as an abstract data type. They contain
\ term {bindings} of objects to their names. Objects can be either
values ​​(full-fledged first-class objects that can be transferred,
copy, assign { \ itd }), and entities (objects of the second class,
which can only be operated by means of their names and, usually, only
with the help of a limited number of special forms or other syntactic
constructions). At the moment we know only one type of such entities
"--- the bindings themselves, they exist only because they" are something,
captured by closures. We consider their properties in more detail when we
to study side effects.

There are many ways to use environments. We may be interested,
if there is any "~ that name in the environment, we can search for the object by its name;
we can search for the binding itself to change it. We can also change
environment, adding new bindings to it, be it current, local, or
global environment. Of course, the same, not ~ all the possibilities are necessary for everyone
from environments. In fact, many environments are useful because
restrictions imposed by them. The following table shows the features
environment variables Scheme:

\ begin {envtable}
Link & \ ii {x}                              \\
The value of & \ ii {x}                              \\
Modifying & \ ic {(set! \ Ii {x} ...)}              \\
The extension & \ ic {(lambda (... \ ii {x} ...) ...)} \\
The definition of & \ ic {(define \ ii {x} ...)}            \\
\ end {envtable}

We will use such tables and concepts from them quite often when
discussing the properties of environments, so let us dwell on them in more detail. The first
The string shows the syntax used to get a reference to a variable,
appeal to her. The second line shows the syntax used to obtain the
the value of the variable. In this case they coincide, but this is by no means the case
not ~ always. The third line shows how to associate a variable with a different value.
The fourth line shows how to extend the environment of the local variables of the new
binding: with the help of the \ ic {lambda} -form or, of course, the same macros like \ ic {let}
or \ ic {let *}, which expand into the \ ic {lambda} form. Finally, the last line
shows how to define a global variable. Do not worry if these
The differences now seem to you too thin and superfluous, and in the future
We will use similar tables to explain the use cases
variables, and there differences will be more noticeable.

For example, the namespace of the \ Lisp 2 functions discussed at the beginning of the chapter,
is described by the following table:

\ begin {envtable}
Link & \ ic {( \ ii {f} ...)}                       \\
The value of & \ ic {(function \ ii {f})}                  \\
Change & Prohibited                               \\
The extension & \ ic {(flet (... ( \ ii {f} ...) ...) ...)} \\
The definition of & is not considered earlier ( \ ic {defun})   \\
\ end {envtable}


\ subsection {Dynamic Variables} %
\ label {lisp1-2-omega / namespaces / ssect: dyn-vars}

\ indexR {dynamic variables} \ indexR {dynamic variables}
\ indexR {dynamic environment} \ indexR {environment! dynamic}
\ term {Dynamic variables} are fundamentally different from lexical ones, so
it makes sense to distinguish them also at the level of environments. The following table
shows the desired properties of our new environment, the environment of dynamic
variables:

\ begin {envtable}
Link & not ~ can be obtained                         \\
The value of & \ ic {(dynamic \ ii {d})}                          \\
Modifying & \ ic {(dynamic-set! \ Ii {d} ...)}                 \\
The extension & \ ic {(dynamic-let (... ( \ ii {d} ...) ...) ...)} \\
The definition of & is not considered here                       \\
\ end {envtable}

The environment takes into account new features: you can create local dynamic
variables \ footnote {The name << local variables >> is not very successful, because
The behavior of dynamic variables is fundamentally different from the behavior of ordinary
(lexical) variables.} using the form \ ic {dynamic-let}, similar to \ ic {let}
and ~ \ ic {flet}; The value of the dynamic variable is obtained using \ ic {dynamic},
but it changes "--- with the help of \ ic {dynamic-set!}.

\ indexE {Lisp3 @ \ protect \ Lisp 3}
\ indexR {Lisp! Lisp3 @ \ protect \ Lisp 3}
So far these are three special forms, but other options will be considered below
implementation. And now we just add to our interpreter \ ic {f.evaluate}
support for the dynamic environment: \ ic {denv}. This environment will contain
only dynamic variables. The new interpreter, let's call it ~ \ Lisp 3, will be
use functions with a prefix ~ \ ic {df.} to not confuse them with the rest. Here
its code. (The form \ ic {flet} is not shown for brevity.)

\ indexC {df.evaluate}
\ indexC {df.evaluate-application}
\ indexC {df.make-function}
\ indexC {df.eprogn}
\ begin {code: lisp}
(define (df.evaluate e env fenv denv)
  (if (atom? e)
      (cond ((symbol? e) (lookup e env))
            ((or (number? e) (string? e) (char? e)
                 (boolean? e) (vector? e))
             (e)
            (else (wrong "Can not evaluate"))))
      (case (car e)
        ((quote) (cadr e))
        ((if) (if (df.evaluate (cadr e) env fenv denv)
                      (df.evaluate (caddr e) env fenv denv)
                      (df.evaluate (cadddr e) env fenv denv)))
        ((begin) (df.eprogn (cdr e) env fenv denv))
        ((set!) (update! (cadr e)
                           env
                           (df.evaluate (caddr e) env fenv denv)))
        ((function)
         (cond ((symbol? (cadr e))
                (f.lookup (cadr e) fenv))
               ((and (pair? (cadr e)) (eq? (car (cadr e)) 'lambda))
                (df.make-function
                 (cadr (cadr e)) (cddr (cadr e)) env fenv))
               (else (wrong "Incorrect function" (cadr e)))))
        ((dynamic) (lookup (cadr e) denv))
        ((dynamic-set!)
         (update! (cadr e)
                  denv
                  (df.evaluate (caddr e) env fenv denv)))
        ((dynamic-let)
         (df.eprogn (cddr e)
                    env
                    fenv
                    (extend denv
                            (map car (cadr e))
                            (map (lambda (e)
                                   (df.evaluate e env fenv denv))
                                 (map cadr (cadr e))))))
        (else (df.evaluate-application (car e)
                                       (df.evlis (cdr e) env fenv denv)
                                       env
                                       fenv
                                       denv)))))

(define (df.evaluate-application fn args env fenv denv)
  (cond ((symbol? fn) ((f.lookup fn fenv) args denv))
        ((and (pair? fn) (eq? (car fn) 'lambda))
         (df.eprogn (cddr fn)
                    (extend env (cadr fn) args)
                    fenv
                    denv))
        (else (wrong "Incorrect functional term" fn))))

(define (df.make-function variables body env fenv)
  (lambda (values ​​denv)
    (df.eprogn body (extend env variables values) fenv denv)))

(define (df.eprogn e * env fenv denv)
  (if (pair? e *)
      (if (pair? (cdr e *))
          (begin (df.evaluate (car e *) env fenv denv)
                 (df.eprogn (cdr e *) env fenv denv))
          (df.evaluate (car e *) env fenv denv))
      empty-begin))
\ end {code: lisp}

To support the new environment, \ ic {denv}, it was required to change the prototypes
\ ic {df.evaluate} and \ ic {df.eprogn} to avoid losing this environment when
calculations. Next, \ ic {df.evaluate} defines three new special forms
for operations on \ ic {denv}, a dynamic environment. There are less noticeable
changes: \ ic {df.evaluate-application} passes to the function \ emph {current}
dynamic environment. We have already met with such behavior
\ seePage [basics / representing-functions / fixing / src: inject-current-env], when
They were forced to transmit the current lexical environment to the called function.

\ indexR {dynamic environment! variants}
\ indexR {environment! dynamic! options}
When using the function, several environments are used simultaneously. there is
An environment with variables and functions captured in the definition of a function. there is
also an environment with dynamic variables that exist at the time of the call. it
environment not ~ can be captured and stored in a ~ closure, each time the value
The dynamic variable is re-searched in the current dynamic environment. It
can be absent there, which, of course, leads to an error. Other
Implementation options: for example, to make a single global environment of dynamic
variables, as in ~ { \ ISLisp }; or give each module its own dynamic
environment, as in ~ { \ EuLisp }; or even have a global lexical environment
variables, as in ~ { \ CommonLisp }.
\ seePage [lisp1-2-omega / namespaces / ssect: dyn-vars-cl]

One of the advantages of a particular environment: it becomes clearly visible which
variables are dynamic and which are not. With every reference to the dynamic
the environment must use a special form with the prefix \ ic {dynamic}.
Explicit references to dynamic variables can not be ignored. This is very
it is important, since in ~ \ Lisp 3 the behavior of the function is determined not by only the values
local variables, but also the current state of the dynamic environment.

\ indexR {bindings!} dynamic}
\ indexR {error handling! dynamic variables}
Among the traditional uses of dynamic environments, the most
it is useful to handle errors. When an error occurs or an exceptional
situation, an object is created that describes what happened, and to this object
an appropriate function that handles the exception
(and, perhaps, try to restore the program's performance). This
the handler could be a common global function, but it would require a heap
unnecessary assignments to use the correct handler in the correct
time. << Hermeticity >> of lexical environments does not go well with the cross-cutting
indicating the various functions of the handlers. Although we can always limit time
life of local variables, concluding calculations in ~ \ ic {let} or \ ic {dynamic-let},
but the ~ \ ic {dynamic-let} has several major advantages:

\ begin {enumerate}
  \ item the bindings created can not be captured;

  \ item these bindings are only available at the ~ compute time,
        nested in the form;

  \ item bindings are automatically deleted after completion
        calculations.
\ end {enumerate}

\ noindent
Therefore \ ic {dynamic-let} is ideal for temporary installation
error-handling functions.

Here is another example of the intelligent use of dynamic variables. Functions
O in ~ { \ CommonLisp } are configured with dynamic variables such as
\ ic {* print-base *}, \ ic {* print-circle *} { \ itd } They contain information
about the base of the numbering for the output of numbers, about whether the output data
contain cyclic lists, and the like. Of course, you can transfer all
this information through arguments, but just imagine that instead of \ ic {(print
\ ii {expression})} you would have to write \ ic {(print \ ii {expression}
\ ii {escape characters?} \ ii {base} \ ii {loops?} \ ii {pretty-print?} \ ii {register?}
\ ii {nesting level} \ ForLayout {display} { \\ } \ ii {vectors?}
\ ii {use -gensym?})}. Everytime. Dynamic variables allow one
Once you set the default values ​​for such parameters and never again
do not specify if not required special behavior.

\ indexR {cyclical data structures}
Scheme uses a similar mechanism to specify I / O ports. Can
write \ ic {(display \ ii {expression})} or \ footnote {These are two different functions
\ ic {display}, which take one and two arguments respectively. There is no ~ Scheme
support for optional arguments and default values ​​at ~ language level.
Lisp ~ supports this idea, so it does not ~ need dynamic variables
to implement this behavior.} \ ic {(display \ ii {expression} \ ii {port})}.
The first form, with a single argument, outputs the \ ii {expression} to the current output port.
The second one uses the explicitly specified port. The function \ ic {with-output-to-file}
Allows you to specify the output port, which will be the current output for the calculation time
expression. You can find the current port using \ ic {current-output-port}. Like this
defined function, \ footnote * {See ~ also the implementation of the function \ ic {list-length} from
{ \ CommonLisp }.} Which outputs the cyclic lists to the current port:

\ indexC {display-cyclic-spine}
\ begin {code: lisp}
(define (display-cyclic-spine list)
  (define (scan l1 l2 flip)
    (cond ((atom? l1) (unless (null? l1)
                          (display ".") (display l1))
                       (display ")"))
          ((eq? l1 l2) (display "...)"))
          (else (display (car l1))
                       (when (pair? (cdr l1)) (display ""))
                       (scan (cdr l1)
                             (if (and flip (pair? l2))
                                 (cdr l2)
                                 l2)
                             (not flip)))))
  (display "(")
  (scan list (cons 42 list) #f))

(display-cyclic-spine; print \ ic {(1 2 3 4 1 ...)}
  (let ((l (list 1 2 3 4)))
    (set-cdr! (cdddr l) l)
    l))
\ end {code: lisp}

You can even create a table of characteristics for the Scheme output ports:

\ begin {envtable}
Link & automatically, if not ~ mentioned explicitly                   \\
The value of & \ ic {(current-output-port)}                                \\
Change & Prohibited                                                 \\
Extension & \ ic {(with-output-to-file \ ii {filename} \ ii {closure})} \\
Definition &                                               n / a \\
\ end {envtable}

\ indexC * {standard-output} {* standard-output *}
\ indexR {dynamic naming conventions}
In ~ { \ CommonLisp } this mechanism explicitly uses dynamic variables.
By default, output functions like \ ic {print} or \ ic {write} use a port,
stored in the variable \ ic {* standard-output *}. \ footnote * {By convention, the names
dynamic variables are surrounded by asterisks to select them.} We can
emulate \ footnote {Of course, this is not ~ { \ CommonLisp }. This is our \ Lisp 3,
defined just above.} \ ic {with-output-to-file} as follows:

\ indexC {with-output-to-file}
\ begin {code: lisp}
(define-with-output-to-file filename thunk)
  (dynamic-let ((* standard-output * (open-input-file filename)))
    (thunk)))
\ end {code: lisp}


\ subsection {Dynamic ~ variables in ~ { \ CommonLisp }} %
\ label {lisp1-2-omega / namespaces / ssect: dyn-vars-cl}

\ indexR {dynamic variables! syntax}
\ indexR {syntax of dynamic variables}
Although { \ CommonLisp } separates dynamic and lexical variables from a ~ point
view of calculations, but the syntax of their use differs little. In it there is no
form \ ic {dynamic-let}, but it can easily be imitated:

{ \ def \ E { \ hbox to 0pt { \ kern 0.15em $ \ equals $ }}
\ begin {code: lisp}
(dynamic-let ((x | $ \ alpha $ |)) | | E | (let ((x | $ \ alpha $ |))
  | | $ \ beta $ | ) (declare (special x))
                          | | $ \ beta $ | )
\ end {code: lisp}}

The difference is that to get the value of the dynamic variable ~ \ ic {x}
inside $ \ beta $ there is no need to use the form \ ic {dynamic}, just write
just ~ \ ic {x}. The reason for this behavior is that the expression \ ic {(declare
(special ~ x))} means two things at the same time: a binding that is set to \ ic {let}
for ~ \ ic {x} must be dynamic, and every reference to ~ \ ic {x} inside
body ~ \ ic {let} should be understood as \ ic {(dynamic ~ x)}.

This is not very convenient, because inside $ \ beta $ one can not access lexical
variable ~ \ ic {x}, we will only see its dynamic namesake. It could have been
go the other way, indicating the specific places where you need to use
dynamic variable ~ \ ic {x} with the help of the construction \ ic {(locally (declare
(special ~ x)) x)}. This is exactly the same as our ~ \ ic {dynamic} form .

The strategy { \ CommonLisp } is to specify the type of binding using the constructs
language. We can implement this mechanism by making the following changes
in the interpreter:

\ indexC {df.evaluate}
\ indexC {special-extend}
\ indexC {cl.lookup}
\ begin {code: lisp}
(define (df.evaluate e env fenv denv)
  (if (atom? e)
      (cond ((symbol? e) (cl.lookup e env))
            ((or (number? e) (string? e) (char? e)
                 (boolean? e) (vector? e))
             (e)
            (else (wrong "Can not evaluate"))))
      (case (car e)
        ((quote) (cadr e))
        ((if) (if (df.evaluate (cadr e) env fenv denv)
                      (df.evaluate (caddr e) env fenv denv)
                      (df.evaluate (cadddr e) env fenv denv)))
        ((begin) (df.eprogn (cdr e) env fenv denv))
        ((set!) (update! (cadr e)
                           env
                           (df.evaluate (caddr e) env fenv denv)))
        ((function)
         (cond ((symbol? (cadr e))
                (f.lookup (cadr e) fenv))
               ((and (pair? (cadr e)) (eq? (car (cadr e)) 'lambda))
                (df.make-function
                 (cadr (cadr e)) (cddr (cadr e)) env fenv))
               (else (wrong "Incorrect function" (cadr e)))))
        ((dynamic) (lookup (cadr e) denv))
        ((dynamic-set!)
         (update! (cadr e)
                  denv
                  (df.evaluate (caddr e) env fenv denv)))
        ((dynamic-let)
         (df.eprogn (cddr e)
                    [(special-extend env]
                                    [(map car (cadr e)))]
                    fenv
                    (extend denv
                            (map car (cadr e))
                            (map (lambda (e)
                                   (df.evaluate e env fenv denv))
                                 (map cadr (cadr e))))))
        (else (df.evaluate-application (car e)
                                       (df.evlis (cdr e) env fenv denv)
                                       env
                                       fenv
                                       denv)))))

(define (special-extend env variables)
  (append variables env))

(define (cl.lookup var env denv)
  (let look ((env env))
    (if (pair? env)
        (if (pair? (car env))
            (if (eq? (caar env) var)
                (cdar env)
                (look (cdr env)))
            (if (eq? (car env) var)
                ;;; looking in the current dynamic environment
                (let lookup-in-denv ((denv denv))
                  (if (pair? denv)
                      (if (eq? (caar denv) var)
                          (cdar denv)
                          (lookup-in-denv (cdr denv)))
                      ;;; if not ~ find, look for in global lexical
                      (lookup var env.global)))
                (look (cdr env))))
        (wrong "No such binding" var))))
\ end {code: lisp}

Now let's see how this works. When \ ic {dynamic-let} creates a dynamic
variable, it does not only bind it to a value in a ~ dynamic environment, but
and marks it as dynamic in a lexical environment, writing down its name.
To support these labels, the mechanism for finding the value by reference changes
( \ ic {cl.lookup}): it must parse the reference to determine the type
(lexical or dynamic), and then find the value
in the right environment. Also, if the variable is not found in the current dynamic
environment, then the next glance is a global lexical environment,
which in ~ { \ CommonLisp } is simultaneously a global dynamic.

Let's give an example of the work of such \ Lisp 3, imitating { \ CommonLisp }:

\ begin {code: lisp}
(dynamic-let ((x2))
  (+ x; dynamic ~ \ ic {x}
     (let ((x (+; lexical
                 xx))); dynamic
       (+ x, lexical
          (dynamic x))))); dynamic
| | \ is | 8
\ end {code: lisp}


\ subsection {Dynamic variables without special forms} %
\ label {lisp1-2-omega / namespaces / ssect: dyn-vars-no-special}

Now, to work with dynamic variables, three special
form. Since Scheme professes minimalism in relation to the quantity
special forms, you should think about other options. We will not consider them
all, and we will stop on the next, as it uses only two functions. The first
the function dynamically links two values; The second function can, on the first
find the second value. The role of dynamic variable identifiers is beautiful
fit the characters. In addition to them, we need some kind of variable data type
point pairs, if we want to change the established relationships. So our decision will be
to satisfy the ascetic traditions of Scheme.

During the study of this approach, we will use an interpreter with two
environments: \ ic {env} and \ ic {denv}. This is the same previous interpreter, only
several things have been removed from it: unnecessary special forms, support
functional environments and references to variables as in ~ { \ CommonLisp }. Remained
only we and dynamic environments. Such an interpreter is somewhat less useful,
since the dynamic environment can no longer be expanded directly, but, the
not less, this environment is still passed to ~ every function "--- and ~ this
enough! To distinguish this variation from the previous ones, its functions are issued
prefix ~ \ ic {dd}.

\ indexC {dd.evaluate}
\ indexC {dd.make-function}
\ indexC {dd.evlis}
\ indexC {dd.eprogn}
\ begin {code: lisp}
(define (dd.evaluate e env denv)
  (if (atom? e)
      (cond ((symbol? e) (lookup e env))
            ((or (number? e) (string? e) (char? e)
                 (boolean? e) (vector? e))
             (e)
            (else (wrong "Can not evaluate"))))
      (case (car e)
        ((quote) (cadr e))
        ((if) (if (dd.evaluate (cadr e) env denv)
                      (dd.evaluate (caddr e) env denv)
                      (dd.evaluate (cadddr e) env denv)))
        ((begin) (dd.eprogn (cdr e) env denv))
        ((set!) (update! (cadr e) env
                           (dd.evaluate (caddr e) env denv)))
        ((lambda) (dd.make-function (cadr e) (cddr e) env))
        (else (invoke (dd.evaluate (car e) env denv)
                      (dd.evlis (cdr e) env denv)
                      denv)))))

(define (dd.make-function variables body env)
  (lambda (values ​​denv)
    (dd.eprogn body (extend env variables values) denv)))

(define (dd.evlis e * env denv)
  (if (pair? e *)
      (if (pair? (cdr e *))
          (cons (dd.evaluate (car e *) env denv)
                (dd.evlis (cdr e *) env denv))
          (list (dd.evaluate (car e *) env denv)))
      '()))

(define (dd.eprogn e * env denv)
  (if (pair? e *)
      (if (pair? (cdr e *))
          (begin (dd.evaluate (car e *) env denv)
                 (dd.eprogn (cdr e *) env denv))
          (dd.evaluate (car e *) env denv))
      empty-begin))
\ end {code: lisp}

As we promised, we now define two functions. The first one is called
\ ic {bind-with-dynamic-extent}; this is a long name, so we'll shorten it to
\ ic {bind / de}. Its first argument is the key ~ \ ic {tag}; second "---
value ~ \ ic {value}, associated with ~ key; third "is the closure of the \ ic {thunk},
function without arguments, which will be called in the extended dynamic
surrounded by.

\ indexC {bind / de}
\ begin {code: lisp}
(definitial bind / de
  (lambda (values ​​denv)
    (if (= 3 (length values))
        (let ((tag (car values))
              (value (cadr values))
              (thunk (caddr values)))
          (invoke thunk '()
                  (extend denv (list tag) (list value))))
        (wrong "Incorrect arity" 'bind / de))))
\ end {code: lisp}

The following function will use the dynamic environment. Since we need
that "~ do something in the case if the dynamic variable with the requested name does not exist,
then the function \ ic {assoc / de} takes the first argument as the key, and the second argument "---
function. It will call the received function and give it a key if it does not find it
in a ~ dynamic environment.

\ indexC {assoc / de}
\ begin {code: lisp}
(definitial assoc / de
  (lambda (values ​​current.denv)
    (if (= 2 (length values))
        (let ((tag (car values))
              (default (cadr values)))
          (let look ((denv current.denv))
            (if (pair? denv)
                (if (eqv? tag (caar denv))
                    (cdar denv)
                    (look (cdr denv)))
                (invoke default (list tag) current.denv))))
        (wrong "Incorrect arity" 'assoc / de))))
\ end {code: lisp}

It is possible to implement several variants of its behavior in ~ depending on
the comparison mechanism used ( \ ic {eqv?} or \ ic {equal?}).
\ seeEx [lisp1-2-omega / ex: assoc-with-comparator]

\ ForLayout {display} { \ clearpage }

We rewrite the previous example:

\ begin {code: lisp}
(bind / de 'x 2
  (lambda () (+ (assoc / de 'x error)
                (let ((x (+ (assoc / de 'x error)
                            (assoc / de 'x error))))
                  (+ x (assoc / de 'x error)))))))
| | \ is | 8
\ end {code: lisp}

Thus, we denied the need to use special forms for
realization of the dynamic variables mechanism. At the same time we got the opportunity
link anything to anything. Of course, this advantage "--- nothing on
compared with the fact that there are much more effective implementations of dynamic
variables (even without multithreading). Although ~ would be the same near binding,
which only requires that the key be a symbol. \ footnote * {Many Lisp implementations
not ~ consider keywords like \ ic {nil} or \ ic {if} characters (and ~ means, and
legal names of variables.}} On the other hand, in this version, not lost
reference transparency. But still access to ~ dynamic variables requires
inexpensive function calls. Our solution is still quite far from the organic
a combination of dynamic and lexical variables in ~ { \ CommonLisp }.

Among all the inconveniences is also worth noting that the use of \ ic {bind / de}
requires using \ ic {assoc / de} and writing a handler function. Although,
of course, with the help of macros this can be hidden. Another inconvenience arises
already for the compiler: after all it needs to generate the code for creation and
use of dynamic variables. Fortunately, they are labeled with calls
corresponding functions, so that the further is left to the compiler:
generate code in the forehead (this is easier) or insert your own, more efficient
implementation.


\ subsection {In conclusion about ~ namespaces} %
\ label {lisp1-2-omega / namespaces / ssect: outputs}

After retreat to the dynamic variables, we return to the idea of ​​namespaces
in general: specialized environments for specialized objects. We already
They saw \ Lisp 3 in the case, and also disassembled the mechanism of dynamic variables
in ~ { \ CommonLisp }.

\ indexE {Lispn \ \ protect \ Lisp { \ protect \ ii {n}}}
\ indexR {Lisp! Lispn @ \ protect \ Lisp { \ protect \ ii {n}}}
Nevertheless, our last implementation is the one with two functions instead of
three special forms, "--- raises a tricky question: if it is \ Lisp { $ n $ }, then
what is ~ $ n $ ? It is based on ~ Scheme, but it still has two environments:
\ ic {env} and ~ \ ic {denv}. At the same time, the calculator has only one, which is
a distinctive feature of Scheme and class ~ \ Lisp 1. However, we had rather
strongly modify the interpreter (just compare \ ic {evaluate} and
\ ic {dd.evaluate}) to implement the functions \ ic {bind / de} and \ ic {assoc / de}. we
collided with ~ primitive functions that can not be expressed in the same language,
if they are not already defined; moreover, the very existence of these functions
deeply affects the process of computing. In the next chapter there will be such a situation
with ~ \ ic {call / cc}.

\ indexR {property lists}
\ indexR {characters! lists of properties}
In short, it seems that we have \ Lisp 1, if we look at the number
calculators, and \ Lisp 2 "--- if you look at namespaces.
paradoxes is the view that the presence of a list of properties of ~ characters is
line \ Lisp { $ n $ }, where $ n $ can be arbitrary.
\ seeEx [lisp1-2-omega / ex: write-put / get-prop]
Since our namespaces objectively exist, and the values ​​of the corresponding
variables are calculated in a special way (even with the help of primitive functions, and
not special forms), then we will consider our implementation as a representative
class ~ \ Lisp 2.

\ bigskip

\ indexC {csetq}
\ indexR {constants}
There remains one more lesson that can be learned from the consideration of lexical and
dynamic variables. { \ CommonLisp } tries to unify access
to ~ variables from different namespaces, giving the same syntax.
Therefore, it is necessary to know the rules by which it determines from which
namespace to take a variable. Unfortunately, they are not always single-valued;
for example, { \ CommonLisp } does not distinguish between global dynamic and global
lexical environment. Further, in ~ \ LISP ~ 1.5 there was a concept of constants,
defined by the special form ~ \ ic {csetq} ( \ ic {setq} for constants).

\ begin {envtable}
Link & \ ii {x}                          \\
The value of & \ ii {x}                          \\
Modifying & \ ic {(csetq \ ii {x} \ ii {form})} \\
Extension & Prohibited                       \\
The definition of & \ ic {(csetq \ ii {x} \ ii {form})} \\
\ end {envtable}

The introduction of constants also makes the syntax ambiguous. When we write \ ic {foo}
"--- this can be either a constant or a variable.
The contradiction in ~ \ LISP ~ 1.5 was as follows: if there is a constant with a name
\ ic {foo}, then return its value; Otherwise to search for the same variable
in the lexical namespace. But: the "constants" can be changed (imagine
yourself!) with the help of the same form \ ic {csetq}, which is used to create them.
Thus, the constants \ LISP ~ 1.5 correspond to the global variables Scheme,
only with ~ the reverse priority: in ~ Scheme first look for local lexical
variable, and the global variable is only the default value for
case if a local variable is not found.

The problem is quite general. If you have access to ~ several
Namespaces use the same syntax, then you need to be clear
prescribed rules for resolving ambiguities.


\ section {Recursion} \ label {lisp1-2-omega / sect: recursion}

\ indexR {recursion}
\ indexR {recursion | seealso {recursion}}
\ indexR {recursion | \ protect \ indexR {recursion}}
Recursion is natural for Lisp, but so far we have not said anything about ~ how
it is realized. Next, we will analyze the different types of recursion and called
they are problems.


\ subsection {Simple recursion} \ label {lisp1-2-omega / recusion / ssect: simple}

\ indexR {recursion! simple}
Probably the most famous simple recursive function is the factorial,
defined as follows:

\ indexC {fact}
\ begin {code: lisp}
(define (fact n)
  (if (= n 0) 1
      (* n (fact (- n 1)))))
\ end {code: lisp}

The language that was defined in the previous chapter does not know what \ ic {define} is,
so let's imagine that this is a macro that is expanded to the next
code:

\ begin {code: lisp}
(set! fact (lambda (n)
             (if (= n 0) 1
                 (* n (fact (- n 1))))))
\ end {code: lisp}

\ indexR {bindings! uninitialized}
Here we see the assignment, changing the value of the variable \ ic {fact}. it
The change is meaningless if the variable \ ic {fact} does not exist. Global
The environment can be considered a place where all possible variables already exist.
In ~ this \ emph {virtual reality} the interpreter (and, more precisely, its part,
responsible for reading programs) must create a binding for the variable when
The first time she sees her name, then calmly continue the work, as if this
the variable is already a hundred years old as here. Each variable already exists before its
first use, and ~ means, its definition "is only a change in the value
existing variable. But with this approach, there is a problem with obtaining
value of a variable that has not yet been assigned ~ anything. The interpreter must
catch this error when the variable is sort of as it is, but it does not have a value yet.
As you can see, the idea of ​​bindings is not so simple, we'll take a closer look at it
in the fourth chapter. \ seePage [chapter: assignment]

\ indexC {define}
You can get rid of the problems with ~ bindings that exist, but still
Not initialized if you take a different position. Let us change only
existing variables; in other words, there is no variable if it was not ~
is defined explicitly. To do this, use the special form \ ic {define},
creating variables. Without it, we ~ do not get ~ anything ~ turn to the ~ variable,
nor set its value. However, let us now look at this from the other side:

\ begin {code: lisp} [label = lisp1-2-omega / recusion / simple / code: redefine]
(define (display-pi)
  (display pi))
(define pi 2.7182818285); th, not that constant
(define (print-pi)
  (display pi))
(define pi 3.1415926536)
\ end {code: lisp}

Is it possible to define \ ic {display-pi}? Her body refers to \ ic {pi},
which is not yet defined. The fourth ~ \ ic {define} fixes the error in the second; but
even if \ ic {define} creates a new binding, can I create another
with ~ that same name?

These questions do not have an unambiguous answer. There are at least two options: consider
global definitions are lexical (as ML ~ does) or consider them
dynamic (as is customary in Lisp).

\ indexR {environment! global! hyperstatic}
\ indexR {global environment! hyperstatic}
\ indexR {hypostatic environment}
\ phantomlabel {lisp1-2-omega / recusion / simple / par: hyperstatic}
In a ~ global environment that is \ emph {completely lexical} ", we will call
its \ term {hyperstatic}, "--- we can not use a variable (refer to
on it, get or change its value), if it does not exist. In ~ it
the definition of the function \ ic {display-pi} will be erroneous, as it refers to
variable ~ \ ic {pi}, which does not exist at the time of the definition. Any call
function \ ic {display-pi} would result in an error << Unknown variable: ~ \ ic {pi} >>
(if ~ it would not happen even when it was determined). But with the function \ ic {print-pi}
everything is in order, it will output the value that existed at the time of its
definition (in this case it is \ ic {2.7182818285}), and nothing can change
output value. Here the redefinition of ~ \ ic {pi} is completely permissible and will create
a new variable ~ \ ic {pi}, which will be used in subsequent expressions
within its scope. The previous example can be
in this way:

\ begin {code: lisp}
(let ((display-pi (lambda () (display pi))))
  (let ((pi 2.7182818285))
    (let ((print-pi (lambda () (display pi))))
      (let ((pi 3.1415926536))
        ...))))
\ end {code: lisp}

In Lisp, as was said, a dynamic approach has been adopted. It is assumed that
There is a maximum of one global variable with a unique name, and this
the variable is visible everywhere, including in its own definition. Lisp
supports forwarding links without any special syntax. (Under
such syntax is understood as explicit declarations like the keyword \ ic {forward}
Pascal or prototypes ISO ~ C ~ \ cite {iso90}.)

The choice is by no means so simple. Returning to the factorial; in an environment where there will be
to calculate \ ic {lambda} -form, it is necessary to answer the question: "What is equal to
value \ ic {fact}? >> If the calculation takes place in a ~ global environment where there is no
binding for \ ic {fact}, then this function in principle can not be recursive.
Cause: the function refers to a variable \ ic {fact} whose value
should be sought in an environment captured by a closure (in the one that consists of
free variables and function parameters). Since at the time of the creation of the closure
the variable \ ic {fact} did not exist, then in the environment it does not exist. Consequently,
for recursion it is necessary what "~ that way to add it.
do by selecting a dynamic approach to the global environment that removes
the question of the existence of variables in the principle. With a hyper-static approach,
make sure that \ ic {define} creates a binding for \ ic {fact} before
calculate the closure, which becomes the value of \ ic {fact}. Summarizing: simple
recursion requires a global environment.


\ subsection {Reciprocal Recursion} \ label {lisp1-2-omega / recusion / ssect: mutual}

\ indexR {recursion! mutual}
Now suppose that we want to define two mutually recursive functions.
Take for example \ ic {odd?} And \ ic {even?}, Realizing (very slow)
check of natural numbers on parity. They are defined as follows:

\ indexC {even?} \ indexC {odd?}
\ indexE {even? @ \ protect \ ic {even?} | seealso { \ protect \ ic {odd?}}}
\ indexE {odd? @ \ protect \ ic {odd?} | seealso { \ protect \ ic {even?}}}
\ begin {code: lisp}
(define (even? n)
  (if (= n 0) #t (odd? (- n 1))))
(define (odd? n)
  (if (= n 0) #f (even? (- n 1))))
\ end {code: lisp}

You can change them in places, but in any case the first definition is not ~
about the second; in this case, \ ic {even?} does not know at the time of the definition of
\ ic {odd?}. And ~ again, it seems, the solution will be the global environment with ~ in advance
created variables: both closures capture the global environment,
in which there are all possible variables, among them, in particular, and the necessary
\ ic {odd?} and ~ \ ic {even?}. Of course, for the time being we will leave aside the question of how
The capture of only the necessary bindings is realized.

It is rather difficult to transfer this behavior to the world with a ~ hyperstatic global
environment, as here the first definition is surely never possible
about the second. One solution is to determine these two functions
at the same time, then there will not be any first and second, and both functions will be able to
refer to each other without problems. (We will return to this question a little later,
after studying local recursion.) For example, when "~ then in ~ \ LISP ~ 1.5 there was
form \ ic {define} with a similar possibility:

\ indexCS {define} {parallel declarations}
\ begin {code: lisp}
(define ((even? (lambda (n) (if (= n 0) #t (odd? (- n 1)))))
         (odd? (lambda (n) (if (= n 0) #f (even? (- n 1)))))))
\ end {code: lisp}

Thus, with the help of a global environment and some tweaks,
express and reciprocal recursion.

But what happens if we need local recursive functions?


\ subsection { \ texorpdfstring {Local ~ recursion in ~ \ Lisp 2} %
{Local recursion in Lisp₂}} %
\ label {lisp1-2-omega / recusion / ssect: local-lisp2}

\ indexR {recursion! local}
Some of the problems we encountered in trying to determine ~ \ ic {fact}
in the global environment are returned when trying to determine ~ \ ic {fact} locally.
We need to do that "~ so that the challenge of \ ic {fact} from the body \ ic {fact} was
recursive. That \ ic {fact} of the functional environment is associated
with a function of calculating the factorial even within the function itself of the computation
factorial. And here the difference between local and
global environments: remember what happens if the desired local
the variable does not exist. Consider the following program in ~ \ Lisp 2:

\ indexC {fact}
\ begin {code: lisp}
(flet ((fact (n) (if (= n 0) 1
                     (* n (fact (- n 1))))))
  (fact 6))
\ end {code: lisp}

The form \ ic {flet} associates the function of calculating the factorial with the name ~ \ ic {fact}
in its internal functional environment. Closing captures
functional and parametric environments, local for the form ~ \ ic {flet}. Thus,
Thus, \ ic {fact} inside \ ic {fact} refers not to the function \ ic {fact}, local
for the body ~ \ ic {flet}, and for what "other function \ ic {fact} from the environment of the whole
forms ~ \ ic {flet}. This function does not have to calculate the factorial (or even
does not exist), so we do not get recursion.

\ indexC {label}
\ indexR {special forms! label @ \ protect \ ic {label}}
This problem was evident even in the ~ LISP ~ 1.5 times . To solve it was introduced
special form ~ \ ic {label}, allowing to define local recursive
function. An example with a ~ factorial is then written as:

\ begin {code: lisp}
(label fact (lambda (n) (if (= n 0) 1
                            (* n (fact (- n 1))))))
\ end {code: lisp}

This form returns an anonymous function that calculates the factorial. Moreover, this is
it is the function that is related to ~ \ ic {fact} in its own body.

\ indexC {labels}
\ indexR {special forms! labels @ \ protect \ ic {labels}}
Unfortunately, we can not say that \ LISP ~ 1.5 was ~ \ Lisp 2, and \ ic {label}, which would be
it was not convenient, it can not easily cope with mutual recursion. therefore
much later, judging by ~ \ cite {hs75}, it was invented its $ n $ "~ ary analog:
\ ic {labels}. This form has the same syntax as ~ \ ic {flet}, but it guarantees,
that closures will be created in an environment where you can refer to local
function. With its help one can define both ~ \ ic {fact}, and ~ mutually recursive
\ ic {odd?} and ~ \ ic {even?}:

\ begin {code: lisp}
(labels ((fact (n) (if (= n 0) 1
                       (* n (fact (- n 1))))))
  (fact 6)) | \ is | 720

(funcall (labels ((even? (n) (if (= n 0) #t (odd? (- n 1))))
                  (odd? (n) (if (= n 0) #f (even? (- n 1)))))
           (function even?))
         4) | \ is | #t
\ end {code: lisp}

So in ~ \ Lisp 2 we have two forms for expanding the local functional
environments: \ ic {flet} and ~ \ ic {labels}.


\ subsection { \ texorpdfstring {Local ~ recursion in ~ \ Lisp 1} %
{Local recursion in Lisp₁}} %
\ label {lisp1-2-omega / recusion / ssect: local-lisp1}

\ indexR {recursion! local}
The problem of defining local recursive functions exists in ~ \ Lisp 1;
it is solved in a similar way. The form ~ \ ic {letrec} (recursive ~ \ ic {let}) is very
is similar in meaning to ~ \ ic {labels}.

In ~ Scheme \ ic {let} has the following syntax:

\ begin {code: lisp}
(let ((| \ ii {variable \ sub {1}} | | \ ii {expression \ sub {1}} |)
      (| \ ii {variable \ sub {2}} | | \ ii {expression \ sub {2}} |)
       ...
      (| \ ii {variable \ sub {n}} | | \ ii {expression \ sub {n}} |))
  | | \ ii {expressions} | ...)
\ end {code: lisp}

\ indexC {let}
\ noindent
And it is equivalent to this expression:

\ begin {code: lisp}
( \ lambda {| \ ii {variable \ sub {1}} | | \ ii {variable \ sub {2}} | ... | \ ii {variable \ sub {n}} |) | \ ii {expressions} | ...)
| | \ ii {expression \ sub {1}} | | | \ ii {expression \ sub {2}} | ... | \ ii {expression \ sub {n}} | )
\ end {code: lisp}

Let us explain what is happening here. First, all the arguments of the application are evaluated:
\ ii {expression \ sub {1}}, \ ii {expression \ sub {2}}, \ dots , \ ii {expression \ sub {n}};
then the variables \ ii {change \ - Naja \ sub {1}}, \ ii {change \ - Naja \ sub {2}}, \ dots ,
\ ii {changes \ - naya \ the sub {n}} associated with ~ just received values;
Finally, the \ ii {expressions} constituting the body ~ \ ic {let} are evaluated in the extended
surrounded inside the implicit form ~ \ ic {begin}, and its value becomes the value
of the whole form ~ \ ic {let}.

As you can see, in principle there is no need to make \ ic {let} a special form, so
as it completely replaces \ ic {lambda}; therefore, \ ic {let} can be only
only a macro. (That's exactly what we did in ~ Scheme: \ ic {let} "--- it's built-in
macro.) The ~ not less, \ ic {let} is good from the point of view of the encoding style, because
which allows you not to divide the variable name and its initial value by a large chunk
code. Now it's time to notice that the initial values ​​of local variables
the forms \ ic {let} are evaluated in the current environment; in ~ extended, only
her body.

\ indexC { letrec }
For those same reasons that we encountered in ~ \ Lisp 2, this is significant
complicates the writing of mutually recursive functions. Therefore, we introduce the form
\ ic {letrec}, the analog of ~ \ ic {labels}.

The syntax ~ \ ic {letrec} is the same as that of ~ \ ic {let}. For example:

\ begin {code: lisp}
(letrec ((even? (lambda (n) (if (= n 0) #t (odd? (- n 1)))))
         (odd? (lambda (n) (if (= n 0) #f (even? (- n 1))))))
  (even? 4))
\ end {code: lisp}

\ indexCS { letrec } {as a macro}
The \ ic {letrec} differs from \ ic {let} in that the expressions "= initializers
are computed in the same environment as the body ~ \ ic {letrec}. Operations that
performs ~ \ ic {letrec}, the same as for ~ \ ic {let}, but their order is somewhat different.
First, the local environment is expanded with the variables \ ic {letrec}. Then in this
the initial values ​​of the variables are calculated. Finally,
in the same extended environment, the body ~ \ ic {letrec} is computed . According to this description
it is quite easy to understand how to implement such behavior. Really,
it suffices to write the following:

\ indexC {even "?} \ indexC {odd"?} \ indexC * {void} {'void}
\ begin {code: lisp}
(let ((even? 'void) (odd?' void))
  (set! even? (lambda (n) (if (= n 0) #t (odd? (- n 1)))))
  (set! odd? (lambda (n) (if (= n 0) #f (even? (- n 1)))))
  (even? 4))
\ end {code: lisp}

First, bindings are created for \ ic {even?} And ~ \ ic {odd?}. (Their initial values
are not important, just \ ic {let} and \ ic {lambda} require what "~ that value.) Then these
variables are initialized with values ​​computed in an environment where the
variables \ ic {even?} and ~ \ ic {odd?}. We say << known >>, because although for
these variables and bindings are created, their values ​​do not make sense, since they
not yet ~ were correctly initialized. Pro \ ic {even?} And \ ic {odd?} Are known
enough to refer to them, but it is still not enough that they
participated in the calculations.

\ indexR {computation order! undefined}
However, such a transformation is not quite correct from "~ for the order of calculations:
indeed, \ ic {let} is exposed in the application of the function, therefore,
\ ic {letrec}, on the idea, should behave the same way, and this means that the initial
The values ​​of the variables must be evaluated as arguments of the function "--- then ~ there are
in an undefined order. Unfortunately, such a variant always calculates them
from left to right. \ seeEx [lisp1-2-omega / ex: orderless-letrec]


\ subsubsection { \ texorpdfstring {Equations and ~ \ protect \ ic {letrec}} %
{Equations and letrec}}

\ indexCS { letrec } {and ~ equations}
There is one more serious problem with the ~ \ ic {letrec} form : its syntax is not ~
strict. With the current interpretation, \ ic {letrec} allows, as initializers
anything, not just functions; whereas \ ic {labels} in ~ { \ CommonLisp }
allows only functions to be defined. That ~ is in ~ Scheme theoretically possible
will write the following:

\ begin {code: lisp}
(letrec ((x (/ (+ x 1) 2))) x)
\ end {code: lisp}

Notice that the variable ~ \ ic {x} is actually determined by itself. It,
it seems that the ordinary equation
%
\ [   x = \ frac {x + 1} {2}   \]
%
It is logical to make the value ~ \ ic {x} the root of this equation. That ~ is such
the expression should return ~ \ ic {1}.

But what if the equation has no roots or if there are several roots?

\ begin {code: lisp}
(letrec ((x (+ x 1))) x); $ x = x + 1 $
(letrec ((x (+ (power x 37) 1))) x); $ x = x ^ {37} + 1 $
\ end {code: lisp}

However, there are sets, like the set of S "= expressions known to you, where
it is easy to see that the equation has a unique solution
\ cite {ms80}. For example, it is possible to determine, without side effects,
infinite list "--- as the root of this << list >> equation:

\ begin {code: lisp}
(letrec ((foo (cons' bar foo))) foo)
\ end {code: lisp}

\ indexR {lazy calculations}
The value of this expression can be either a lazily calculated infinite
list \ ic {(bar bar bar ...)}, as it is done in ~ \ cite {fw76, pj87}, and
looped data structure (less expensive from a computational point of view):

\ begin {code: lisp}
(let ((foo (cons 'bar' wait)))
  (set-cdr! foo foo)
  foo)
\ end {code: lisp}

Effectively, this is the same thing, but in reality it does not. In general, from "~ for all these
ambiguity is to enter a rule that prohibits the use of a variable,
defined \ ic {letrec}, to determine the value of this same variable. In the two
In the previous examples, it was necessary to know the value of ~ \ ic {x} in order that
initialize ~ \ ic {x}. Now they are obviously mistaken. However, we
remember that the order of initialization in ~ Scheme must be undefined, and therefore,
Some constructions permitted by this rule may be erroneous
in some implementations, but work in others. Consider the following example:

\ begin {code: lisp}
(letrec ((x (+ y 1))
         (y 2))
  x)
\ end {code: lisp}

If \ ic {y} is initialized to ~ \ ic {x}, then everything is in order. In the opposite case
an error occurs because we want to increase the value of the variable ~ \ ic {y},
which already exists, but still does not matter. Some Scheme compilers
and ML analyze the expressions "= initializers and perform topological sorting
to determine the appropriate initialization order. Naturally, this solution
Also not ~ always works; in particular, with the mutual dependence of \ footnote {
\ ic {(42 ~ 42)} is quite suitable as the root of the given equation, but why
namely ~ \ ic {42}?} like this:

\ begin {code: lisp}
(letrec ((xy) (yx)) (list xy))
\ end {code: lisp}

The examples considered remind us of our discussion about the global environment
and semantics \ ic {define}. There arose a similar problem: what to do
with uninitialized bindings and how to find out that they are generally
exist.


\ subsection {Declaring uninitialized bindings} %
\ label {lisp1-2-omega / recusion / ssect: uninitialized}

\ indexR {bindings! uninitialized}
Officially, the semantics of Scheme consider \ ic {letrec} a derived form; i.e
convenient, but by no means an obligatory reduction. Accordingly, any
\ ic {letrec} -form can be rewritten with the help of primitive forms Scheme. Slightly
earlier we tried to do this by temporarily associating the variables \ ic {letrec}
with the value \ ic {void}. To Unfortunately, this is also initialization, so that calls
It is impossible to catch uninitialized variables in this way. Our
the situation is aggravated by the fact that none of the four special forms of Scheme
not ~ allows you to create "native" uninitialized bindings.

\ indexC * {UFO} { \ # <UFO>}
In the first approximation, it would be possible to solve the problem using an object
\ ic { \ # <UFO>} \ seePage [basics / s: env / ufo] instead of \ ic {void}. Nothing can be done with him
do: neither ~ add to it a number, nor ~ take it ~ \ ic {car}; however, it's still the same
full object, so that it can be passed as an argument to ~ \ ic {cons}, and
then the next program will not be ~ wrong and return \ ic { \ # <UFO>}:

\ begin {code: lisp}
(letrec ((foo (cons' foo foo))) (cdr foo))
\ end {code: lisp}

The reason for this behavior is that uninitialization "is a property
the most binding, not its value. Therefore, we can not solve the problem,
using first class objects.

\ ForLayout {display} { \ medskip }

\ indexC * {uninitialized} { \ # <uninitialized>}
And ~ all the same, many implementations give uninitialized variables a special
value. Let's call it \ ic { \ # <uninitialized>} and suppose it's
high-grade object. Any variable with this value is considered
uninitialized. Therefore, using \ ic {void} instead of
\ ic { \ # <uninitialized>}, we get the desired opportunity to detect the error.
However, this possibility is too obvious: nothing forbids the transfer
\ ic { \ # <uninitialized>} to a function as an argument, and hence, it is no longer possible
assume that all arguments of the function have values. We will have to
every time to check whether it really is:

\ begin {code: lisp}
(define (fact n)
  (if (eq? n '# <uninitialized>)
      (wrong "Uninitialized n")
      (if (= n 0) 1
          (* n (fact (- n 1))))))
\ end {code: lisp}

Doing so with ~ all variables "is a too big fee for \ ic {letrec}.
So \ ic { \ # # <uninitialized>} can not be made a full-fledged object, it should
be a special internal value of the interpreter that can not be used
in ~ programs. In order to be able to use them safely, it is necessary to
special syntax.

\ ForLayout {display} { \ medskip }

The third solution is to introduce a special form that creates
uninitialized bindings. For example, move the syntax of \ ic {let} from
{ \ CommonLisp } that performs this action in ~ Scheme:

\ begin {code: lisp}
(let (| \ ii {variable} | ...)
  ...)
\ end {code: lisp}

If the variable name is specified by itself, without the initial value, then the binding
to ~ this name will not be initialized. If we need its value, then we
we will have to check whether this variable was initialized or not.
Now you can write a normal implementation of \ ic {letrec}. In the following code
the variables \ ii {temp \ sub {i}} are "hygienic": they are given special
names guaranteed not conflicting with ~ variable names \ ic {letrec} or
free variables of her body.

\ ForLayout {display} { \ clearpage }

{ \ def \ N # 1 { \ ii {name \ sub {# 1}}}
\ def \ T # 1 { \ ii {temp \ sub {# 1}}}
\ def \ E # 1 { \ ii {expression \ sub {# 1}}}
\ def \ Q { \ hbox to 0pt { \ kern 0.3em $ \ equals $ }}
\ begin {code: lisp}
( let \ r \ n \ | 1 | | \ E 1 |) (let (| \ N 1 | ... | | \ N n |)
         ... (let ((| \ T 1 | | \ E 1 |)
         (| \ N n | | \ E n |)) | \ Q | ...
  | | \ ii {body} | ) (| \ T n | | \ E n |))
                                      (set! | \ N 1 | | \ T 1 |)
                                      ...
                                      (set! | \ N n | | \ T n |)
                                      | | \ ii {body} | ))
\ end {code: lisp}}

\ indexCS {let} {special form}
Total, the problem is solved with acceptable efficiency: only uninitialized
variables cause overhead, because you have to pay for features.
But now the form ~ \ ic {let} is not just a syntactic sugar, now it's
a full-fledged special form that the interpreter must handle.
Add the appropriate code to the \\ ic {evaluate}:

\ begin {code: lisp}
...
((let)
 (eprogn (cddr e)
         (extend env
                 (map (lambda (binding)
                        (if (symbol? binding) binding
                            (car binding)))
                      (cadr e))
                 (map (lambda (binding)
                        (if (symbol? binding) the-uninitialized-marker
                            (evaluate (cadr binding) env)))
                      (cadr e))))) ...
\ end {code: lisp}

The variable \ ic {the-uninitialized-marker} belongs to the definition language. We set
her, for example, like this:

\ indexC {the-uninitialized-marker}
\ begin {code: lisp}
(define the-uninitialized-marker (cons 'not' initialized))
\ end {code: lisp}

Of course, now it is necessary to embed support for this internal value
in the function \ ic {lookup}. The function \ ic {update!} Does not need to change ~
obvious reasons. References to ~ \ ic {wrong} are responsible for two different types
errors: non-existent binding and uninitialized binding.

\ indexC {lookup}
\ begin {code: lisp}
(define (lookup id env)
  (if (pair? env)
      (if (eq? (caar env) id)
          (let ((value (cdar env)))
            (if (eq? value the-uninitialized-marker)
                (wrong "Uninitialized binding" id)
                value))
          (lookup id (cdr env)))
      (wrong "No such binding" id)))
\ end {code: lisp}

After wandering through the desert ~ semantics and syntax, we ~ finally "~ it turned out
form \ ic {letrec}, allowing to define local mutually recursive functions.


\ subsection {Recursion without assignment} %
\ label {lisp1-2-omega / recusion / ssect: no-assignment}

\ indexR {language! purely functional}
\ indexR {recursion! without assignment}
The form \ ic {letrec}, which we considered, uses assignments for
ensuring the correct calculation of the initial values. Languages ​​called
\ emph {purely functional}, do not have ~ at their disposal operators
assignments; in them there are essentially no side effects, but what, how
is not a by-effect of calculations, is the change in the value of a variable?

As a programming paradigm, the prohibition on assignment has its own
advantages: it guarantees the preservation of referential transparency and this
Unleashes the hands of many optimizations, allowing you to move and parallelize
parts of programs, use lazy calculations { \ itd } However, if not
possibility to use assignments, then some algorithms become
not so simple, but also somewhat complicating the transfer of programs to real
computers, because side effects are an integral part of their work.

\ indexC { letrec }
The first thing that comes to the head is to make \ ic {letrec} one more special
form, as it is done in ~ ML and similar languages. Modify \ ic {evaluate}
for processing this case:

\ begin {code: lisp}
...
((letrec)
 (let ((new env (extend env
                        (map car (cadr e))
                        (map (lambda (binding) the-uninitialized-marker)
                             (cadr e)))))
      (map (lambda (binding); \ ic {map} in the name of the mess!
             (update! (car binding)
                      new-env
                      (evaluate (cadr binding) new-env)))
           (cadr e))
      (eprogn (cddr e) new-env))) ...
\ end {code: lisp}

In this case, side effects are still present, but at the level
interpreter, inside \ ic {update!}; from the point of view of the determined by-product language
no effects. It is worth noting that we intentionally do not specify the order of calculations,
using \ ic {map}, which, unlike ~ \ ic {for-each}, is free to process
list in ~ any convenient order. \ footnote * {True, paying for it
need to collect a useless list, which is then deleted after
creation.}


\ subsubsection { \ texorpdfstring %
{ \ protect \ ic {letrec} and ~ fully lexical global environment} %
{letrec and a fully lexical global environment}}

In a ~ hyperstatic global environment, the variable can only be used
after it has been determined. With such limitations we can not easily
to determine neither reciprocally, nor even simply recursive functions. The form \ ic {letrec}
solves this problem, and at the same time serves as an indicator of recursive definitions.

\ begin {code: lisp}
(letrec ((fact (lambda (n)
                 (if (= n 0) 1 (* n (fact (- n 1)))))))
  (letrec ((odd? (lambda (n) (if (= n 0) #f (even? (- n 1)))))
           (even? (lambda (n) (if (= n 0) #t (odd? (- n 1))))))
    ...))
\ end {code: lisp}

\ noindent
In this case, \ ic {letrec} creates forward links to \ ic {fact}, \ ic {odd?}
and ~ \ ic {even?}, so the definitions will work in a ~ hyperstatic environment.


\ subsubsection {Paradoxical Combinator}

\ indexR {fixed point}
\ indexR {combinators! Y @ \ protect \ comb {Y}}
\ indexE {Y @ \ protect \ comb {Y}, combinator}
\ indexR {fixed point theorem}
\ indexR {fixed point}
\ indexR {lambda calculus @ $ \ lambda $ -calculus! combinators}
If you were dealing with ~ $ \ lambda $ "= calculus, then you probably remember that
such \ emph {fixed-point combinators} and how the most well-known
of which "--- \ emph {paradoxical} or Y-combinator. ~ $ f $ has
a fixed point if in its domain of definition there exists an element ~ $ x $ such that,
that $ f (x) = x $ . The combinator ~ \ comb {Y} takes any function
$ \ lambda $ "= calculus and returns its fixed point. This idea is expressed
in one of the most beautiful and informative theorems of $ \ lambda $ "= calculus:

\ begin {theorem} {Fixed point theorem}
$ \ exists  \ comb {Y} \ colon  \ forall F \ colon  \ comb {Y} F = F ( \ comb {Y} F) $
\ end {theorem}

In Lisp terms, \ comb {Y} "is the value of the expression

\ begin {code: lisp}
(let ((W (lambda (w)
           (lambda (f)
             (f ((ww) f))))))
  (WW))
\ end {code: lisp}

Proving this is very simple. Assuming that \ comb {Y} is equal to $ (WW) $ ,
then what should be $ W $ \! , so that $ (WW) F $ equals $ F ((WW) F) $ ?
It is obvious that the function $ W $ \! must be nothing else than $ \ lambda W. \ lambda F.
F ((WW) F) $ . The above expression only records this idea on Lisp.

\ indexR {combinators! Z @ \ protect \ comb {Z}}
\ indexE {Z @ \ protect \ comb {Z}, combinator}
\ indexR {this-conversion @ $ \ eta $ -conversion}
True, here there is a slight difficulty from "~ for the accepted in ~ Scheme transfer
arguments on the value. The term \ ic {((w ~ w) ~ f)} should not be calculated too early,
so we are forced to add an extra (in the $ \ lambda $ "~ calculus)
$ \ eta $ "= conversion to avoid problems.In the end, we come to the so-called
Z-combinator, where \ ic {(lambda (x) (... x))} means $ \ eta $ "= conversion:

\ ForLayout {display} { \ clearpage }

\ indexC {fix}
\ begin {code: lisp}
(define fix
  (let ((d (lambda (w)
             (lambda (f)
               (f (lambda (x) (((ww) f) x)))))))
  (dd)))
\ end {code: lisp}

The hardest thing about this definition is "to understand how it works.
and let's do it. Define the function \ ic {meta-fact}:

\ indexC {meta-fact}
\ begin {code: lisp} [label = lisp1-2-omega / recursion / y-combinator / code: meta-fact]
(define (meta-fact f)
  (lambda (n)
    (if (= n 0) 1
        (* n (f (- n 1))))))
\ end {code: lisp}

This function is suspiciously similar to the factorial. Having checked, we are convinced that
\ ic {(meta-fact fact)} calculates the factorial with the same success as \ ic {fact},
perhaps a little slower. Now suppose that we know the motionless
point $ f $ of the function \ ic {meta-fact}: $ f = \ text { \ ic {(meta-fact $ f $ )}} $ . This
The fixed point by definition is the solution of the following functional
equations with respect to ~ $ f $ :

\ begin {code: lisp}
| | \ ii {f} | = (lambda (n)
      (if (= n 0) 1
          (* n (| \ ii {f} | (- n 1)))))
\ end {code: lisp}

So, what is ~ $ f $ ? Nothing other than the well-known factorial!

Generally speaking, there is not a single ground to believe that the equation above has
solution and that it is unique. (Of course, these terms should be defined strictly
mathematically, but this is beyond the scope of this book.) Indeed, there are both
at least one more solution:

\ indexC {fact}
\ begin {code: lisp}
(define (another-fact n)
  (cond ((<n 1) (- n))
        ((= n 1) 1)
        (else (* n (another-fact (- n 1)))))))
\ end {code: lisp}

\ indexR {fixed point! smallest}
Please check that \ ic {another-fact} is also a fixed point
\ ic {meta-fact}. Analyzing possible fixed points, one can come to the conclusion,
that there is such a domain of definition on which their values ​​coincide: all of them
calculate the factorial of natural numbers. Their behavior is different only when
the original version of \ ic {fact} falls into an infinite loop. For negative integers
numbers \ ic {another-fact} returns one value, although it could well ~ be returned
some other, because the original functional equation does not indicate, %
\ footnote * {For a more detailed explanation, see ~ in ~ \ cite {man74}.} what to do in a ~ such
the case. If you order the functions by some measure of their certainty, then
exist the smallest fixed point "--- the least definite solution
functional equation.

The mathematical meaning of global recursive definitions like \ ic {fact} consists of
in the fact that they define functions that are the smallest fixed points
corresponding functional equations. When we write:

\ begin {code: lisp}
(define (fact n)
  (if (= n 0) 1
      (* n (fact (- n 1)))))
\ end {code: lisp}

\ noindent
then we actually write the equation with respect to the variable ~ \ ic {fact}. The form
\ ic {define} solves this equation and associates the resulting solution
with ~ variable ~ \ ic {fact}. This interpretation takes us far from the discussion
initialization of global variables
\ seePage [lisp1-2-omega / recusion / ssect: simple]
and turns \ ic {define} into a magic solver of equations. In fact,
\ ic {define} is implemented exactly as previously suggested. Simply recursion
in the global environment, together with the normal order of computations
are able to find the smallest fixed points.

And now we return to ~ \ ic {fix}, our Z-combinator, and trace how
\ ic {((fix ~ meta-fact) ~ 3)} is calculated . Remember that functions do not have
side effects, which means that the results of calculations can be freely substituted
friend in ~ friend than we will use.

\ indexC {fix}
\ begin {code: lisp}
((fix meta-fact) 3)
| | \ Equals | (((dd) | \ begin {where}
                    \ - d { \ eq } \ begin {complex}
                              \ - (lambda (w)
                              \ -   (lambda (f)
                              \ -    (f (lambda (x)
                              \ -         (((ww) f) x)))))
                              \ end {complex}
                    \ end {where} |
     meta-fact)
    3)

| | \ Equals | (((lambda (f); \ term {step I}
       (f (lambda (x)
            (((ww) f) x)))) | \ begin {where}
                               \ - w { \ eq } \ begin {complex}
                                         \ - (lambda (w)
                                         \ -   (lambda (f)
                                         \ -    (f (lambda (x)
                                         \ -         (((ww) f) x)))))
                                         \ end {complex}
                              \ end {where} |
     meta-fact)
    3)

| | \ Equals | ((meta-fact (lambda (x)
                 (((ww) f) x))) | \ begin {where}
                                  \ - w { \ eq } \ begin {complex}
                                            \ - (lambda (w)
                                            \ -   (lambda (f)
                                            \ -     (f (lambda (x)
                                            \ -          (((ww) f) x)))))
                                            \ end {complex}
                                  \ end {where} |
    3)
| | \ Equals | ((lambda (n)
      (if (= n 0) 1
          (* n (f (- n 1))))) | \ begin {where}
                                \ - f { \ eq } \ begin {complex}
                                          \ - (lambda (x)
                                          \ -   (((ww) meta-fact) x)) \ begin {where}
                                                         \ - w { \ eq } \ begin {complex *} {6.2cm}
                                                                   \ - (lambda (w)
                                                                   \ -   (lambda (f)
                                                                   \ -     (f (lambda (x)
                                                                   \ -          (((ww) f) x)))))
                                                                   \ end {complex *}
                                                         \ end {where}
                                                  \ end {complex}
                                \ end {where} |
    3)
| | \ Equals | (* 3 (f 2)) | \ begin {where}
                        \ - f { \ eq } \ begin {complex}
                                  \ - (lambda (x)
                                  \ -   (((ww) meta-fact) x)) \ begin {where}
                                                             \ - w { \ eq } \ begin {complex *} {4.8cm}
                                                                       \ - (lambda (w)
                                                                       \ -   (lambda (f)
                                                                       \ -     (f (lambda (x)
                                                                       \ -          (((ww) f) x)))))
                                                                       \ end {complex *}
                                                                      \ end {where}
                                  \ end {complex}
                        \ end {where} |
| | \ Equals | (* 3 (((ww) meta-fact) 2)) | \ begin {where}
                                        \ - w { \ eq } \ begin {complex}
                                                  \ - (lambda (w)
                                                  \ -   (lambda (f)
                                                  \ -     (f (lambda (x)
                                                  \ -          (((ww) f) x)))))
                                                  \ end {complex}
                                        \ end {where} |
| | \ Equals | (* 3 (((lambda (f); \ term {step II}
            (f (lambda (x)
                 (((ww) f) x)))) | \ begin {where}
                                    \ - w { \ eq } \ begin {complex}
                                              \ - (lambda (w)
                                              \ -   (lambda (f)
                                              \ -     (f (lambda (x)
                                              \ -          (((ww) f) x)))))
                                              \ end {complex}
                                    \ end {where} |
          meta-fact)
         2))
\ end {code: lisp}

Let's stop for a minute to notice that at step ~ II we got the same thing
expression, as in step ~ I. Naturally, it will appear in the third ~ time:

\ begin {code: lisp}
(* 3 (* 2 (((lambda (f)
              (f (lambda (x)
                   (((ww) f) x)))) | \ begin {where}
                                      \ - w { \ eq } \ begin {complex}
                                                \ - (lambda (w)
                                                \ -   (lambda (f)
                                                \ -     (f (lambda (x)
                                                \ -          (((ww) f) x)))))
                                                \ end {complex}
                                      \ end {where} |
            meta-fact)
           1 )))
| | \ Equals | (* 3 (* 2 ((meta-fact (lambda (x)
                           (((ww) meta-fact) x))) | \ begin {where}
                                                    \ - w { \ eq } \ begin {complex *} {4.5cm}
                                                              \ - (lambda (w)
                                                              \ -   (lambda (f)
                                                              \ -     (f (lambda (x)
                                                              \ -          (((ww) f) x)))))
                                                              \ end {complex *}
                                                    \ end {where} |
              1 )))
| | \ Equals | (* 3 (* 2 ((lambda (n)
                (if (= n 0) 1
                    (* n (f (- n 1))))) | \ begin {where}
                                          \ - f { \ is } ...
                                          \ end {where} |
              1 )))
| | \ Equals | (* 3 (* 2 (if (= n 0) 1 (* n (f (- n 1)))))) | \ begin {where}
                                                         \ - n { \ is } 1
                                                         \ - f { \ is } ...
                                                         \ end {where} |
| | \ Equals | (* 3 (* 2 1))

| | \ is | 6th
\ end {code: lisp}

Note that in the calculation process, we really use
function that calculates the factorial. This is the value of the expression:

\ begin {code: lisp}
(lambda (x)
  ((((ww) f) x)) | \ begin {where}
                  \ - f { \ eq } meta-fact
                  \ - w { \ is } \ begin {complex}
                            \ - (lambda (w)
                            \ -   (lambda (f)
                            \ -     (f (lambda (x)
                            \ -          (((ww) f) x)))))
                            \ end {complex}
                  \ end {where} |
\ end {code: lisp}

\ indexR {self-application! and recursion}
The idea is that thanks to self-application, we remember how to create anew
function, and do this every time you need to calculate
recursive call.

\ indexCS {define} {as solver of equations}
Thus, one can obtain a simple recursion without using side
effects, only with ~ \ ic {fix}, a combinator of a fixed point. Thanks
\ comb {Y} (or \ ic {fix}), \ ic {define} can be defined as the solver of recursive
equations; it takes an equation and associates the solution with the transferred name.
In the end, if we pass the \ ic {define} equation for the factorial, then with ~ \ ic {fact}
the following value will be associated:

\ begin {code: lisp}
(fix (lambda (fact)
       (lambda (n)
         (if (= n 0) 1
             (* n (fact (- n 1)))))))
\ end {code: lisp}

Similarly, one can solve systems of equations, and therefore,
recursive functions, collecting their equations together:

\ indexC {odd "?} \ indexC {even"?}
\ begin {code: lisp}
(define odd-and-even
  (fix (lambda (f)
         (lambda (which)
           (case which
             ((odd) (lambda (n) (if (= n 0) #f
                                    ((f 'even) (- n 1)))))
             ((even) (lambda (n) (if (= n 0) #t
                                     ((f 'odd) (- n 1))))))))))
(define odd? (odd-and-even 'odd))
(define even? (odd-and-even 'even))
\ end {code: lisp}

This method has one big drawback: inefficiency, even in comparison
with a ~ naive implementation of ~ \ ic {letrec}. (And ~ all the same, see ~ \ cite {roz92, ser93}.)
not ~ less, it is used, especially in ~ as a book example. Functional
languages, according to \ cite {pj87}, also do not particularly like this method, since,
First, it is inefficient, and secondly, \ ic {fix} does not work well with ~ systems
O types. Indeed, \ ic {fix} takes a functional, %
\ footnote * {McCarthy's terminology from ~ \ cite {mae + 62}: functional "is a function,
which takes other functions as arguments.} A receiving function of type $ \ alpha  \ to
\ beta $ , and returns the fixed point of this functional. Then ~ is the type ~ \ ic {fix}
is an
%
\ [  \ big \ ( \ alpha  \ to  \ beta ) \ to ( \ alpha  \ to  \ beta ) \ big ) \ to ( \ alpha  \ to  \ beta ) \]

\ indexR {self-application! typing}
But in the definition of \ ic {fix} there is a self-application: \ ic {(d ~ d)}. Denoting its type
$ \ gamma $ , we have:
%
\ [  \ gamma = \ gamma  \ to ( \ alpha  \ to  \ beta ) \]

A non-trivial type system is required, so that it can be expressed
like a recursive type, or we'll have to implement \ ic {fix}
in the interpreter as a primitive function, since it can not be expressed by means
the language itself.


\ section {Conclusion} \ label {lisp1-2-omega / sect: conclusions}

In this chapter, we went through the most notable of the questions to which the community
Lisp for the past few decades has never been able to give an unambiguous
answer. Having considered the reasons for these disagreements, we realized that they were not at all ~ such
serious in nature. Most of them are related to ambiguity
interpretation of the meaning of the form \ ic {lambda} and various ways of applying functions.
Although the idea of ​​the function is well developed in mathematics, but
in ~ functional ~ (!) languages ​​like Lisp, this is by no means ~ so. Different opinions on
such questions "--- this is part of the history of Lisp. Like studying the history of the native
people, their knowledge makes it easier to understand the reasons for some decisions in the design
language, and also improves the style of programming in general.

Also, this chapter demonstrates the essential importance of the concept of binding.
In ~ \ Lisp 1, a variable (name) is associated with a ~ unique binding (possibly
global), which in turn is associated with ~ any value. So
as the binding is unique, we are talking about the value of a variable, not about the value
bind this variable. If we consider bindings as an abstract type
data, we can say that objects of this type are created by connecting forms,
their meaning is determined by calculation, they are changed by assignment, and can be
are captured when creating a closure, if the closure body refers to a variable,
which is associated with this binding.

Bindings are not ~ full objects. They do not exist in isolation from
variables and can only be changed indirectly. Actually, bindings are useful
precisely because they are tightly connected with their variables.

\ indexR {form! binding}
\ indexR {binding forms}
\ indexR {scope! lexical}
Side by side with the connecting forms follows the idea of ​​scopes. Region
visibility of a variable "is a space in the text of the program where you can
refer to ~ this variable. The scope of variables created
form \ ic {lambda}, is limited by the body of the given form. Therefore it is called
textual or lexical.

Assignment introduces a multitude of ambiguities into the idea of ​​binding, we will study this
the question is discussed in more detail in the following chapters.


\ section {Exercises} \ label {lisp1-2-omega / sect: exercises}

\ begin {exercise} \ label {lisp1-2-omega / ex: funcall}
The following expression is written in { \ CommonLisp }. How would you translate it into ~ Scheme?

\ begin {code: lisp}
(funcall (function funcall) (function funcall) (function cons) 1 2)
\ end {code: lisp}
\ end {exercise}

\ begin {exercise} \ label {lisp1-2-omega / ex: lexical}
What will this program return to the pseudo { \ CommonLisp } from this chapter?
What does she remind you of?

\ begin {code: lisp}
(defun test (p)
  (function bar))

(let ((f (test #f)))
  (defun bar (x) (cdr x))
  (funcall f '(1.2)))
\ end {code: lisp}
\ end {exercise}

\ begin {exercise} \ label {lisp1-2-omega / ex: innovations}
Implement in your interpreter the first two innovations from
section ~ \ ref {lisp1-2-omega / sect: extensions}
\ seePage [lisp1-2-omega / sect: extensions]. It is about interpreting numbers and
lists as functions.
\ end {exercise}

\ begin {exercise} \ label {lisp1-2-omega / ex: assoc-with-comparator}
You can teach the function \ ic {assoc / de} to explicitly take a comparator (like \ ic {eq?},
\ ic {equal?} { \ itp }) through the argument, rather than ~ set it inside. Do it.
\ end {exercise}

\ begin {exercise} \ label {lisp1-2-omega / ex: dynamic}
Using \ ic {bind / de} and \ ic {assoc / de}, write macros that emulate
special forms \ ic {dynamic-let}, \ ic {dynamic} and ~ \ ic {dynamic-set!}.
\ end {exercise}

\ begin {exercise} \ label {lisp1-2-omega / ex: write-put / get-prop}
\ indexC {putprop} \ indexC {getprop}
Write functions \ ic {getprop} and \ ic {putprop}, which implement lists of properties.
Any character has a personal list of properties in the form of pairs << key >> --- value >>;
Addition to ~ this list is performed by the function ~ \ ic {putprop}, search for the value by
The key is provided by the function \ ic {getprop}. Also, of course, must be fulfilled
statement

\ begin {code: lisp}
(begin (putprop 'symbol' key 'value)
       (getprop 'symbol' key)) | \ is | value
\ end {code: lisp}
\ end {exercise}

\ begin {exercise} \ label {lisp1-2-omega / ex: label}
Define the special form \ ic {label} in \ Lisp 1.
\ end {exercise}

\ begin {exercise} \ label {lisp1-2-omega / ex: labels}
Define the special form \ ic {labels} in \ Lisp 2.
\ end {exercise}

\ begin {exercise} \ label {lisp1-2-omega / ex: orderless-letrec}
\ indexC { letrec }
Think about how to implement \ ic {letrec} with the help of \ ic {let} and \ ic {set!} So,
so that the order of evaluating the values ​​of "= initializers was undefined.
\ end {exercise}

\ begin {exercise} \ label {lisp1-2-omega / ex: fixn}
\ indexR {combinators! fixed point! universal}
Our ~ combinator of the fixed point on Scheme showed a flaw: it
supports only unary functions. Implement \ ic {fix2} working
with binary functions. Then \ ic {fixN}, supporting the functions of any arity.
\ end {exercise}

\ begin {exercise} \ label {lisp1-2-omega / ex: nfixn}
Next, write the function \ ic {NfixN} returning fixed points for the list
functionals of arbitrary arity. It can be used, for example, as follows
way:

\ begin {code: lisp}
(let ((odd-and-even
       (NfixN (list (lambda (odd? Even?); \ Ic {odd?}
                      (lambda (n)
                        (if (= n 0) #f (even? (- n 1)))))
                    (lambda (odd? even?); \ ic {even?}
                      (lambda (n)
                        (if (= n 0) #t (odd? (- n 1)))))))))
  (set! odd? (car odd-and-even))
  (set! even? (cadr odd-and-even)))
\ end {code: lisp}
\ end {exercise}

\ begin {exercise} \ label {lisp1-2-omega / ex: klop}
Consider the function \ ic {klop}. Is it a combinator of a fixed point?
Try to prove or disprove that \ ic {(klop $ f $ )} also returns
the fixed point ~ $ f $ is similar to ~ \ ic {fix}.

\ indexC {klop}
\ begin {code: lisp}
(define klop
  (let ((r (lambda (schem)
             (lambda (f)
               (f (lambda (n)
                    (((meches) f) n)))))))
    (rrrrrr)))
\ end {code: lisp}
\ end {exercise}

\ begin {exercise} \ label {lisp1-2-omega / ex: hyper-fact}
\ indexC {fact}
If the function \ ic {hyper-fact} is defined as follows:

\ begin {code: lisp}
(define (hyper-fact f)
  (lambda (n)
    (if (= n 0) 1
        (* n ((ff) (- n 1))))))
\ end {code: lisp}

\ noindent
then that will return \ ic {((hyper-fact hyper-fact) ~ 5)}?
\ end {exercise}

\ section * {Recommended Reading} %
\ label {lisp1-2-omega / sect: recommended-reading}

In addition to the previously mentioned work on $ \ lambda $ "= calculus, \ cite {ss78a} also has
the sense of reading about the analysis of functions in ~ \ cite {mos70} and comparative analysis \ Lisp 1
and \ Lisp 2 in ~ \ cite {gp88}.

In ~ \ cite {gor88} there is an interesting introduction to ~ $ \ lambda $ "= calculus.

The combinator \ comb {Y} is discussed in more detail in ~ \ cite {gab88}.
